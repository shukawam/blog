<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tech on Shukawam's Daily Blog</title><link>https://shukawam.github.io/blog/categories/tech/</link><description>Recent content in tech on Shukawam's Daily Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 19 Sep 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://shukawam.github.io/blog/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Oracle Linux にApache Kakfaをインストールする</title><link>https://shukawam.github.io/blog/blog/2021/0919-getting-started-kafka/</link><pubDate>Sun, 19 Sep 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0919-getting-started-kafka/</guid><description>始めに 積んでおいたKafka のオライリー本を読み始め、これから本格的に Kafka を勉強しようと思っています。それに際して、手軽に触れる環境があったほうがいいな、ということでさくっと Oracle Linux 上に構築します。
手順 まずは、アーカイブをダウンロードします。ダウンロードサイトはこちらにあります。
wget https://ftp.tsukuba.wide.ad.jp/software/apache/kafka/2.8.0/kafka_2.13-2.8.0.tgz 展開します。
tar -xzf kafka_2.13-2.8.0.tgz 環境変数を設定しておきます。$HOME/.bashrcに以下を追記
# Kafka settings export KAFKA_HOME=$HOME/bin/kafka_2.13-2.8.0 Zookeeper, Kafka を起動します。
# Zookeeper $KAFKA_HOME/bin/zookeeper-server-start.sh -daemon $KAFKA_HOME/config/zookeeper.properties # Kafka $KAFKA_HOME/bin/kafka-server-start.sh -daemon $KAFKA_HOME/config/server.properties 検証用に Topic の作成、メッセージの publish/subscribe を行います。
# Create &amp;#34;test&amp;#34; topic $KAFKA_HOME/bin/kafka-topics.sh --create --zookeeper localhost:2181 --topic test --partitions 5 --replication-factor 1 Created topic test. # Publish message $KAFKA_HOME/bin/kafka-console-producer.sh --bootstrap-server localhost:9092 --topic test &amp;gt;The first message. &amp;gt;The second message.</description></item><item><title>HiveMQ を Kubernetes 上に構築する</title><link>https://shukawam.github.io/blog/blog/2021/0806-getting-started-hivemq/</link><pubDate>Fri, 06 Aug 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0806-getting-started-hivemq/</guid><description>始めに 業務で MQTT を扱う必要性が出てきたので、自分で色々遊べる MQTT Broker を Kubernetes 上に構築します。
About HiveMQ HiveMQ は、IoT デバイスとの間で MQTT ベースでメッセージングを可能にするプラットフォームです。標準的な MQTT の機能は完全にサポートされてあり、HA 構成や既存システムへの統合等様々な拡張機能を提供しています。エディションは商用版と OSS 版の 2 種類が存在しますが、今回は OSS 版を用います。また、HiveMQ の実行方法はいくつか選択肢があります。
フルマネージドな HiveMQ Cloud Service を使用する HiveMQ のパッケージをダウンロードして使う Docke 上で実行する AWS 上で実行する(HiveMQ がプリインストールされた AMI を使用する) Azure 上で実行する(Azure Resource Manager を使用して、HiveMQ 環境を作成する) 今回は、可用性なども考慮して Kubernetes(Oracle Container Engine for Kubernetes)上に HiveMQ のクラスターを構築します。
構築手順 非常に簡単です。まずは、HiveMQ Cluster 用を以下のように書きます。
apiVersion: v1 kind: ReplicationController metadata: name: hivemq-replica spec: replicas: 3 selector: app: hivemq-cluster1 template: metadata: name: hivemq-cluster1 labels: app: hivemq-cluster1 spec: containers: - name: hivemq-pods image: hivemq/hivemq3:dns-latest ports: - containerPort: 8080 protocol: TCP name: web-ui - containerPort: 1883 protocol: TCP name: mqtt env: - name: HIVEMQ_DNS_DISCOVERY_ADDRESS value: &amp;#34;hivemq-discovery.</description></item><item><title>Argo CD - Getting Started でちょっとハマったこと</title><link>https://shukawam.github.io/blog/blog/2021/0721-argocd-getting-started/</link><pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0721-argocd-getting-started/</guid><description>始めに タイトルの通りです。Argo CD の Getting Started を実施した際のハマったことを書き起こしておきます。
何が起きたのか？ 新しく作った Kubernetes クラスタに Argo CD(v2.0.4) を導入しようと思ったところ、ドキュメントの Getting Started 通りには行かなかった。Argo CD の初期パスワードは、 v1.9 以降 Kubernetes の secret に格納されているので確認するためには、kubectl で確認すればよい。
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&amp;#34;{.data.password}&amp;#34; | base64 -d が、確認したところ、argocd-initial-admin-secret なんて存在しないとエラーメッセージが出力された。(原因までは調査してないです。)
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&amp;#34;{.data.password}&amp;#34; | base64 -d Error from server (NotFound): secrets &amp;#34;argocd-initial-admin-secret&amp;#34; not found 関連 Issue あったのでリンク張っておきます。(2021/07/25 追記);
https://github.com/argoproj/argo-cd/issues/6787
解決策 修正されるまでは、admin ユーザーのパスワードが Kubernetes のsecretで管理されているのでそれを単純に変更すればよい。
kubectl -n argocd patch secret argocd-secret \ &amp;gt; -p &amp;#39;{&amp;#34;stringData&amp;#34;: {&amp;#34;admin.</description></item><item><title>FIDO2 Tips &amp; Considering</title><link>https://shukawam.github.io/blog/blog/2021/0406-webauthn-tips/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0406-webauthn-tips/</guid><description>始めに FIDO2 をアプリケーションに組み込むときのちょっとした Tips や考慮しないといけないことを思いつくままにまとめてみようと思います。思いつく＆何か新しい発見があるたびに記事は随時更新していきます。
Tips Virtual Authenticators Tab まずは、Chrome の拡張機能の紹介です。組織のポリシーなどで会社支給のパソコンからinternalの認証器が呼び出せないパターンもあるでしょう。例えば、デモやちょっとした検証をやりたいのにわざわざそのために USB セキュリティキーを買うのもちょっと馬鹿らしいですよね。そんな時に非常に役に立ちます。
使い方自体は非常に簡単で、まずは chrome ウェブストア - Virtual Authenticators Tabで当該機能を有効化する。
Virtual Authenticators Tab を追加しますか？ というポップアップが出てくるので、拡張機能を追加 を押して追加する。
確認には、おなじみのwebauthn.ioが良いと思います。
まずは、DevTool を開き追加されているVirtual Authenticators内にあるEnable Virtual Authenticator Environmentのチェックボックスにチェックを入れます。
後は、お好きな仮想認証器を生成してください。一応、設定できるパラメータを解説すると
Protocol ctap2 CTAP1 を FIDO2 用に拡張したもの u2f CTAP1 のことでクライアントと外部認証器との通信プロトコルのこと 選択肢では、internalが選択できそうですが、作成の際にエラーメッセージが出力されます Transport usb USB セキュリティキーのこと(e.g. Yubikey) nfc Near Field Communication(e.g. Suica, Pasmo) ble Bluetooth Smart/Bluetooth Low Energy Technology internal プラットフォームの認証器のこと(e.</description></item><item><title>WebAuthn DeepDive #2 - Attestation</title><link>https://shukawam.github.io/blog/blog/2021/0404-webauthn-deep-dive/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0404-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。
About Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。
Deep Dive まずは、原文を読んでみましょう。
Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision.</description></item><item><title>WebAuthn DeepDive #1 - navigator.credentials.create()</title><link>https://shukawam.github.io/blog/blog/2021/0324-webauthn-deep-dive/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0324-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、WebAuthnよりも CTAP の話が多めかも。
Deep Dive この辺の仕様を読んでいく。
※図はhttps://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_APIから参照
全体の流れとしては、
navigator.credentials.create()が実行される authenticatorMakeCredential()を実行するためのパラメータを組み立てる 認証器のauthenticatorMakeCredential()が呼び出される authenticatorMakeCredential()を実行した結果がブラウザに返される となっています。WebAuthn が実行され、認証器のauthenticatorMakeCredential()が呼び出される所から順番に見ていきます。
2. navigator.credentials.create()の実行 navigator.credentials.create()が呼び出されると、認証器のauthenticatorMakeCredential()を実行するためのパラメータを組み立てて実行します。その際、authenticatorMakeCredential()実行のために必要なパラメータの仕様は、こちらに公開されています。一部抜粋して読んでいきたいと思います。(ひとまず今回は、Required のものだけ確認していきます)
パラメータ名 型 概要 clientDataHash Byte Array clientData のハッシュ rp PublicKeyCredentialRpEntity Relying Party の情報 user PublicKeyCredentialUserEntity 新しく生成する Credential に紐づくユーザーの情報 pubKeyCredParams CBOR Array 生成する Credential のパラメータ(type: public-keyで固定, alg: 公開鍵の暗号化アルゴリズム) clientDataHash Hash of the ClientData contextual binding specified by host.</description></item><item><title>Spring Native Getting Started</title><link>https://shukawam.github.io/blog/blog/2021/0322-spring-boot-native-image/</link><pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0322-spring-boot-native-image/</guid><description>始めに Spring Nativeを使って、Spring Boot アプリケーションを Native Image 化してみます。
手順 Spring Initializr を使用してひな形を作成します。今回は、Helath Check のエンドポイントを一つ有するアプリケーションを作成します。
curl -G https://start.spring.io/starter.zip -o spring-boot-native-image-sample.zip -d javaVersion=11 -d dependencies=web,actuator,native % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 57164 100 57164 0 0 106k 0 --:--:-- --:--:-- --:--:-- 106k 解凍します。
unzip spring-boot-native-image-sample.zip -d spring-boot-native-image Archive: spring-boot-native-image-sample.zip inflating: spring-boot-native-image/.gitignore inflating: spring-boot-native-image/HELP.md inflating: spring-boot-native-image/mvnw creating: spring-boot-native-image/src/ creating: spring-boot-native-image/src/main/ creating: spring-boot-native-image/src/main/java/ creating: spring-boot-native-image/src/main/java/com/ creating: spring-boot-native-image/src/main/java/com/example/ creating: spring-boot-native-image/src/main/java/com/example/demo/ inflating: spring-boot-native-image/src/main/java/com/example/demo/DemoApplication.</description></item><item><title>Nest.jsで接続先情報を環境変数から非同期で取得する</title><link>https://shukawam.github.io/blog/blog/2020/0911-nestjs-async-multiple-db-connection/</link><pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2020/0911-nestjs-async-multiple-db-connection/</guid><description>始めに ※ブログを一か所にまとめるため、以前 Qiita に投稿した記事の移行しています。
Nest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。
環境 Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6 実装手順 必要最小限の実装 参考）Nest.js Document &amp;gt; TECHNIQUES &amp;gt;Database
ライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。
$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。
import { Module } from &amp;#34;@nestjs/common&amp;#34;; import { TypeOrmModule } from &amp;#34;@nestjs/typeorm&amp;#34;; import { ItemModule } from &amp;#34;./item/item.module&amp;#34;; import { Connection } from &amp;#34;typeorm&amp;#34;; import { join } from &amp;#34;path&amp;#34;; @Module({ imports: [ ItemModule, // DBの接続情報を定義 TypeOrmModule.</description></item><item><title>Hugo + GitHub Pagesでブログを始めた</title><link>https://shukawam.github.io/blog/blog/2020/0909-about-this-blog/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2020/0909-about-this-blog/</guid><description>始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。
このブログについて 環境 静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages という環境で、作成し運用されています。
選定理由 いくつか背景があるので、順にお話します。
Qiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。
静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc &amp;hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。
ホスティング先 ホスティング先には、いくつか条件がありました。
無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。
docs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。
&amp;gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.</description></item></channel></rss>