<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>tech on shukawam diary</title><link>https://shukawam.github.io/blog/categories/tech/</link><description>Recent content in tech on shukawam diary</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 15 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://shukawam.github.io/blog/categories/tech/index.xml" rel="self" type="application/rss+xml"/><item><title>Chaos Mesh を OKE で試す</title><link>https://shukawam.github.io/blog/2021/1215-chaos-mesh/</link><pubDate>Wed, 15 Dec 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/1215-chaos-mesh/</guid><description>始めに Kubernetes 上に構築したシステムにカオスエンジニアリングを導入する際の（おそらく）最有力候補である Chaos Mesh を色々触って試してみます。とりあえず、今回は構築まで。
手順 インストール用のスクリプトが提供されているので、それを使います。
curl -sSL https://mirrors.chaos-mesh.org/v2.1.1/install.sh | bash しばらくすると、chaos-testing という namespace にいくつかリソースが作成されます。
kubectl get pods,service -n chaos-testing こんな感じです。
NAME READY STATUS RESTARTS AGE pod/chaos-controller-manager-87f7677bf-jw27d 1/1 Running 0 11m pod/chaos-controller-manager-87f7677bf-wc4zx 1/1 Running 0 11m pod/chaos-controller-manager-87f7677bf-z4xpm 1/1 Running 0 11m pod/chaos-daemon-8nr8f 1/1 Running 0 11m pod/chaos-daemon-jrl4q 1/1 Running 0 11m pod/chaos-dashboard-85db5f48d8-vzxtf 1/1 Running 0 11m NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/chaos-daemon ClusterIP None &amp;lt;none&amp;gt; 31767/TCP,31766/TCP 11m service/chaos-dashboard NodePort 10.</description></item><item><title>Argo CD - Getting Started でちょっとハマったこと</title><link>https://shukawam.github.io/blog/2021/0721-argocd-getting-started/</link><pubDate>Wed, 21 Jul 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/0721-argocd-getting-started/</guid><description>始めに タイトルの通りです。Argo CD の Getting Started を実施した際のハマったことを書き起こしておきます。
何が起きたのか？ 新しく作った Kubernetes クラスタに Argo CD(v2.0.4) を導入しようと思ったところ、ドキュメントの Getting Started 通りには行かなかった。Argo CD の初期パスワードは、 v1.9 以降 Kubernetes の secret に格納されているので確認するためには、kubectl で確認すればよい。
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&amp;#34;{.data.password}&amp;#34; | base64 -d が、確認したところ、argocd-initial-admin-secret なんて存在しないとエラーメッセージが出力された。(原因までは調査してないです。)
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&amp;#34;{.data.password}&amp;#34; | base64 -d Error from server (NotFound): secrets &amp;#34;argocd-initial-admin-secret&amp;#34; not found 関連 Issue あったのでリンク張っておきます。(2021/07/25 追記);
https://github.com/argoproj/argo-cd/issues/6787
解決策 修正されるまでは、admin ユーザーのパスワードが Kubernetes のsecretで管理されているのでそれを単純に変更すればよい。
kubectl -n argocd patch secret argocd-secret \ &amp;gt; -p &amp;#39;{&amp;#34;stringData&amp;#34;: {&amp;#34;admin.</description></item><item><title>FIDO2 Tips &amp; Considering</title><link>https://shukawam.github.io/blog/2021/0406-webauthn-tips/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/0406-webauthn-tips/</guid><description>始めに FIDO2 をアプリケーションに組み込むときのちょっとした Tips や考慮しないといけないことを思いつくままにまとめてみようと思います。思いつく＆何か新しい発見があるたびに記事は随時更新していきます。
Tips Virtual Authenticators Tab まずは、Chrome の拡張機能の紹介です。組織のポリシーなどで会社支給のパソコンからinternalの認証器が呼び出せないパターンもあるでしょう。例えば、デモやちょっとした検証をやりたいのにわざわざそのために USB セキュリティキーを買うのもちょっと馬鹿らしいですよね。そんな時に非常に役に立ちます。
使い方自体は非常に簡単で、まずは chrome ウェブストア - Virtual Authenticators Tabで当該機能を有効化する。
Virtual Authenticators Tab を追加しますか？ というポップアップが出てくるので、拡張機能を追加 を押して追加する。
確認には、おなじみのwebauthn.ioが良いと思います。
まずは、DevTool を開き追加されているVirtual Authenticators内にあるEnable Virtual Authenticator Environmentのチェックボックスにチェックを入れます。
後は、お好きな仮想認証器を生成してください。一応、設定できるパラメータを解説すると
Protocol ctap2 CTAP1 を FIDO2 用に拡張したもの u2f CTAP1 のことでクライアントと外部認証器との通信プロトコルのこと 選択肢では、internalが選択できそうですが、作成の際にエラーメッセージが出力されます Transport usb USB セキュリティキーのこと(e.g. Yubikey) nfc Near Field Communication(e.g. Suica, Pasmo) ble Bluetooth Smart/Bluetooth Low Energy Technology internal プラットフォームの認証器のこと(e.</description></item><item><title>WebAuthn DeepDive #2 - Attestation</title><link>https://shukawam.github.io/blog/2021/0404-webauthn-deep-dive/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/0404-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。
About Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。
Deep Dive まずは、原文を読んでみましょう。
Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision.</description></item><item><title>WebAuthn DeepDive #1 - navigator.credentials.create()</title><link>https://shukawam.github.io/blog/2021/0324-webauthn-deep-dive/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/0324-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、WebAuthnよりも CTAP の話が多めかも。
Deep Dive この辺の仕様を読んでいく。
※図はhttps://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_APIから参照
全体の流れとしては、
navigator.credentials.create()が実行される authenticatorMakeCredential()を実行するためのパラメータを組み立てる 認証器のauthenticatorMakeCredential()が呼び出される authenticatorMakeCredential()を実行した結果がブラウザに返される となっています。WebAuthn が実行され、認証器のauthenticatorMakeCredential()が呼び出される所から順番に見ていきます。
2. navigator.credentials.create()の実行 navigator.credentials.create()が呼び出されると、認証器のauthenticatorMakeCredential()を実行するためのパラメータを組み立てて実行します。その際、authenticatorMakeCredential()実行のために必要なパラメータの仕様は、こちらに公開されています。一部抜粋して読んでいきたいと思います。(ひとまず今回は、Required のものだけ確認していきます)
パラメータ名 型 概要 clientDataHash Byte Array clientData のハッシュ rp PublicKeyCredentialRpEntity Relying Party の情報 user PublicKeyCredentialUserEntity 新しく生成する Credential に紐づくユーザーの情報 pubKeyCredParams CBOR Array 生成する Credential のパラメータ(type: public-keyで固定, alg: 公開鍵の暗号化アルゴリズム) clientDataHash Hash of the ClientData contextual binding specified by host.</description></item><item><title>Spring Native Getting Started</title><link>https://shukawam.github.io/blog/2021/0322-spring-boot-native-image/</link><pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2021/0322-spring-boot-native-image/</guid><description>始めに Spring Nativeを使って、Spring Boot アプリケーションを Native Image 化してみます。
手順 Spring Initializr を使用してひな形を作成します。今回は、Helath Check のエンドポイントを一つ有するアプリケーションを作成します。
curl -G https://start.spring.io/starter.zip -o spring-boot-native-image-sample.zip -d javaVersion=11 -d dependencies=web,actuator,native % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 57164 100 57164 0 0 106k 0 --:--:-- --:--:-- --:--:-- 106k 解凍します。
unzip spring-boot-native-image-sample.zip -d spring-boot-native-image Archive: spring-boot-native-image-sample.zip inflating: spring-boot-native-image/.gitignore inflating: spring-boot-native-image/HELP.md inflating: spring-boot-native-image/mvnw creating: spring-boot-native-image/src/ creating: spring-boot-native-image/src/main/ creating: spring-boot-native-image/src/main/java/ creating: spring-boot-native-image/src/main/java/com/ creating: spring-boot-native-image/src/main/java/com/example/ creating: spring-boot-native-image/src/main/java/com/example/demo/ inflating: spring-boot-native-image/src/main/java/com/example/demo/DemoApplication.</description></item><item><title>Hugo + GitHub Pagesでブログを始めた</title><link>https://shukawam.github.io/blog/2020/0909-about-this-blog/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/2020/0909-about-this-blog/</guid><description>始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。
このブログについて 環境 静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages という環境で、作成し運用されています。
選定理由 いくつか背景があるので、順にお話します。
Qiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。
静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc &amp;hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。
ホスティング先 ホスティング先には、いくつか条件がありました。
無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。
docs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。
&amp;gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.</description></item></channel></rss>