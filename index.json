[{"title":"Angularでバックエンドサーバにプロキシする","date":"","description":"","body":"始めに ローカル環境でフロントエンド、バックエンドの開発を行うと以下の様な構成で開発することがある。\n フロントエンド：http://localhost:4200 バックエンド：http://localhost:8080  オリジンが異なるパターンです。特に設定を加えずにバックエンドの API をコールしようとすると、CORS Policy で通信が拒否されます。\nそのため、Angular を用いた開発では webpack dev server のプロキシサポートを使用して、特定の URL パスをバックエンドサーバに転送するという事が良く取られます。今回は、その手順（良く忘れるので自分への備忘録）です。\n手順  proxy.conf.jsonをsrc/に以下の内容で新規に作成する。  { \u0026#34;/api\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, \u0026#34;secure\u0026#34;: false } } CLI 設定ファイル（angular.json）の設定を修正する。  \u0026#34;architect\u0026#34;: { \u0026#34;serve\u0026#34;: { \u0026#34;builder\u0026#34;: \u0026#34;@angular-devkit/build-angular:dev-server\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;browserTarget\u0026#34;: \u0026#34;your-application-name:build\u0026#34;, \u0026#34;proxyConfig\u0026#34;: \u0026#34;src/proxy.conf.json\u0026#34; }, ng serveで開発サーバを再起動する  参考  バックエンドサーバーへのプロキシ  ","ref":"/blog/blog/20201014/"},{"title":"Angular9系以上でBootstrap4を使う","date":"","description":"","body":"始めに ※こちらの記事は以前 Qiita で執筆したAngular9 で Bootstrap4 を使うの移行記事です。執筆当時とバージョンなどを微修正しています。\n Angular 9 系に Bootstrap4 (ng-bootstrap) を適用する手順です。 通常の Bootstrap（jQuery, popper.js 依存）を使用してもよいですが、余計なライブラリに依存することになる事になるため、おすすめしません。（Angular の思想にも反します。）  ng-bootstrap は、Bootstrap が依存している jQuery, popper.js の実装を Angular の component に差し替えています。   メジャーバージョンはしっかりと確認する。  特に Angular5 と Angular6+では CLI の設定ファイル周りが大きく変更となっています。   公式の英語ドキュメント読むのめんどいって方向け。  環境 タイトルにもある通り、今回は Angular10 系に Bootstrap4 系を適用します。\n$ ng --version _ _ ____ _ ___ / \\ _ __ __ _ _ _| | __ _ _ __ / ___| | |_ _| / △ \\ | '_ \\ / _` | | | | |/ _` | '__| | | | | | | / ___ \\| | | | (_| | |_| | | (_| | | | |___| |___ | | /_/ \\_\\_| |_|\\__, |\\__,_|_|\\__,_|_| \\____|_____|___| |___/ Angular CLI: 10.1.2 Node: 12.18.4 OS: win32 x64 Angular: ... Ivy Workspace: Package Version ------------------------------------------------------ @angular-devkit/architect 0.1001.2 (cli-only) @angular-devkit/core 10.1.2 (cli-only) @angular-devkit/schematics 10.1.2 (cli-only) @schematics/angular 10.1.2 (cli-only) @schematics/update 0.1001.2 (cli-only) 手順 ng-bootstrapをインストールする。公式ドキュメントにも記載がありますが、Angular CLI を使用してセットアップすることが強く推奨されています。（依存している Bootstrap のインストール、angular.jsonへの設定反映、app.module.tsへのインポートをコマンド一発で実行できます。）\n$ ng add @ng-bootstrap/ng-bootstrap また、Angular 9.0.0 以上かつ ng-bootstrap 6.0.0 の場合は、@angular/localizeを polyfills に追加する必要があります。\n$ ng add @angular/localize 動作確認 app.component.html\n\u0026lt;button type=\u0026#34;button\u0026#34; class=\u0026#34;btn btn-primary\u0026#34;\u0026gt;BUTTON\u0026lt;/button\u0026gt; アプリケーションを起動後、http://localhost:4200にアクセスし、以下の画面が見えれば OK です。\n参考  ng-bootstrap#getting-started setting-up-localization-with-the-angular-cli  ","ref":"/blog/blog/20201007/"},{"title":"Spring Boot ApplicationからAutonomous Transaction Processing（ATP）に接続する","date":"","description":"","body":" 始めに 環境 手順  ATP を作成する ウォレットをダウンロードする アプリケーションで DB の接続設定をする  ひな型作成 Doma2 を依存関係に追加  Eclipse 用の設定を追加   DB の接続設定を追加   起動の確認を行う API の作成   終わりに 参考  始めに Spring Boot アプリケーションから Autonomous Transaction Processing（以下、ATP） に接続する手順を記載します。また、動作確認用に簡単な API も作成したいと思います。OR Mapper として Doma2 を使用していますが、何でも構いません。\n環境  Windows 10 Java 15  Spring Boot 2.3.4.RELEASE Doma 2.43.0   Autonomous Transaction Processing  手順 ATP を作成する まずは、接続先の DB がないと話にならないので以下のように入力し ATP を作成します。\n 表示名：My Work（任意の名前で結構です） データベース名：MyWork（任意の名前で結構です） ワークロード・タイプの選択：トランザクション処理 デプロイメント・タイプの選択：共有インフラストラクチャ データベースの構成：Always Free にチェックを入れておくと良いです 管理者資格証明の作成：パスワードポリシーを満たすようなパスワードを入力します ネットワーク・アクセスの選択：すべての場所からのセキュア・アクセスを許可 ライセンスタイプの選択：ライセンス込み  しばらくすると、プロビジョニングが完了し作成した ATP が使用可能になります。\nウォレットをダウンロードする 作成した ATP を選択し、「DB 接続」ボタンを押下すると、ウォレット（資格証明）がダウンロードできるのでダウロードし、適当なディレクトリに展開しておきます。\nアプリケーションで DB の接続設定をする ひな型作成 Spring Initializrから zip をダウンロードし、任意の IDE に取り込みます。\n参考までに今回のアプリケーションのひな型を作成するのに使用した設定の URLを貼っておきます。\nDoma2 を依存関係に追加 build.gradleに以下を追加します。\nplugins { // ... 省略  id \u0026#39;com.diffplug.eclipse.apt\u0026#39; version \u0026#39;3.22.0\u0026#39; // ... 1 } // ... 省略  dependencies { // ... 省略  implementation \u0026#39;org.seasar.doma:doma-core:2.43.0\u0026#39; implementation \u0026#39;org.seasar.doma.boot:doma-spring-boot-starter:1.4.0\u0026#39; annotationProcessor \u0026#39;org.seasar.doma:doma-processor:2.43.0\u0026#39; } // ... 省略 Eclipse 用の設定を追加 本項目は、IDE として Eclipse を使用している場合のみ、必要な項目となります。注釈処理周りの設定を実施してくれるプラグインのため、Eclipse × Doma の組み合わせで開発している方は是非入れましょう。\nDB の接続設定を追加 src/main/resources/application.propertiesに以下のプロパティを追加します。\n# Database connection settings spring.datasource.driver-class-name=oracle.jdbc.OracleDriver spring.datasource.url=jdbc:oracle:thin:@\u0026lt;DatabaseName\u0026gt;_medium?TNS_ADMIN=\u0026lt;YourPath\u0026gt; spring.datasource.username=\u0026lt;Username\u0026gt; spring.datasource.password=\u0026lt;Password\u0026gt; # Doma2 doma.dialect=oracle  DatabaseName：先ほど作成した DB の名前を指定します（今回だとMyWork） YourPath：Wallet ファイルを展開したディレクトリを指定します Username：DB のユーザ名を指定します Password：指定したユーザのパスワードを指定します  起動の確認を行う  . ____ _ __ _ _ /\\\\ / ___'_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.3.4.RELEASE) 2020-10-05 22:59:56.496 INFO 17712 --- [ restartedMain] SpringbootAtpConnectionSampleApplication : Starting SpringbootAtpConnectionSampleApplication on DESKTOP-DCQ3PA2 with PID 17712 (C:\\Git\\springboot-atp-connection-sample\\bin\\main started by kwmr1 in C:\\Git\\springboot-atp-connection-sample) 2020-10-05 22:59:56.499 INFO 17712 --- [ restartedMain] SpringbootAtpConnectionSampleApplication : No active profile set, falling back to default profiles: default 2020-10-05 22:59:56.544 INFO 17712 --- [ restartedMain] o.s.b.devtools.restart.ChangeableUrls : The Class-Path manifest attribute in C:\\Users\\kwmr1\\.gradle\\caches\\modules-2\\files-2.1\\com.oracle.database.jdbc\\ojdbc8\\19.3.0.0\\967c0b1a2d5b1435324de34a9b8018d294f8f47b\\ojdbc8-19.3.0.0.jar referenced one or more files that do not exist: file:/C:/Users/kwmr1/.gradle/caches/modules-2/files-2.1/com.oracle.database.jdbc/ojdbc8/19.3.0.0/967c0b1a2d5b1435324de34a9b8018d294f8f47b/oraclepki.jar 2020-10-05 22:59:56.544 INFO 17712 --- [ restartedMain] o.s.b.devtools.restart.ChangeableUrls : The Class-Path manifest attribute in C:\\Users\\kwmr1\\.gradle\\caches\\modules-2\\files-2.1\\com.oracle.database.security\\oraclepki\\19.3.0.0\\e52a34f271c6c62ee1a73b71cc19da5459b709f\\oraclepki-19.3.0.0.jar referenced one or more files that do not exist: file:/C:/Users/kwmr1/.gradle/caches/modules-2/files-2.1/com.oracle.database.security/oraclepki/19.3.0.0/e52a34f271c6c62ee1a73b71cc19da5459b709f/osdt_core.jar,file:/C:/Users/kwmr1/.gradle/caches/modules-2/files-2.1/com.oracle.database.security/oraclepki/19.3.0.0/e52a34f271c6c62ee1a73b71cc19da5459b709f/osdt_cert.jar,file:/C:/Users/kwmr1/.gradle/caches/modules-2/files-2.1/com.oracle.database.security/oraclepki/19.3.0.0/oracle.osdt/osdt_core.jar,file:/C:/Users/kwmr1/.gradle/caches/modules-2/files-2.1/com.oracle.database.security/oraclepki/19.3.0.0/oracle.osdt/osdt_cert.jar 2020-10-05 22:59:56.544 INFO 17712 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : Devtools property defaults active! Set 'spring.devtools.add-properties' to 'false' to disable 2020-10-05 22:59:56.544 INFO 17712 --- [ restartedMain] .e.DevToolsPropertyDefaultsPostProcessor : For additional web related logging consider setting the 'logging.level.web' property to 'DEBUG' 2020-10-05 22:59:57.493 INFO 17712 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2020-10-05 22:59:57.502 INFO 17712 --- [ restartedMain] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2020-10-05 22:59:57.502 INFO 17712 --- [ restartedMain] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.38] 2020-10-05 22:59:57.590 INFO 17712 --- [ restartedMain] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2020-10-05 22:59:57.590 INFO 17712 --- [ restartedMain] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1046 ms 2020-10-05 22:59:57.795 INFO 17712 --- [ restartedMain] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService 'applicationTaskExecutor' 2020-10-05 22:59:58.076 INFO 17712 --- [ restartedMain] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting... 2020-10-05 23:00:29.179 ERROR 17712 --- [ restartedMain] oracle.simplefan.FanManager : attempt to configure ONS in FanManager failed with oracle.ons.NoServersAvailable: Subscription time out 2020-10-05 23:00:29.204 INFO 17712 --- [ restartedMain] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed. 2020-10-05 23:00:29.273 INFO 17712 --- [ restartedMain] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 35729 2020-10-05 23:00:29.310 INFO 17712 --- [ restartedMain] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path '' 2020-10-05 23:00:29.326 INFO 17712 --- [ restartedMain] SpringbootAtpConnectionSampleApplication : Started SpringbootAtpConnectionSampleApplication in 33.109 seconds (JVM running for 33.881) 上記のように表示されれば、Spring Boot アプリケーションから ATP への接続は成功しています。（結構起動までに時間がかかります。大体 30 秒程度）\nAPI の作成 今回は API を作成することがメインではないので、中身を真似したい場合は、リポジトリを参照してください。\ne2eに格納している簡易テスト用のスクリプトを実行し、以下のような結果が返却されれば成功です。\nHTTP/1.1 200 Content-Type: application/json Transfer-Encoding: chunked Date: Mon, 05 Oct 2020 14:50:37 GMT Connection: close [ { \u0026quot;employeeId\u0026quot;: \u0026quot;001\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Hillel Slovak\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;002\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Jack Sherman\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;003\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;DeWayne McKnigh\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;004\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;John Frusciante\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;005\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Arik Marshall\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;006\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Jesse Tobias\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;007\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Dave Navarro\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;008\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;Josh Klinghoffer\u0026quot; }, { \u0026quot;employeeId\u0026quot;: \u0026quot;009\u0026quot;, \u0026quot;employeeName\u0026quot;: \u0026quot;John Frusciante\u0026quot; } ] こちらも初回リクエストは、15000ms 程度かかりますね。\n余談ですが、返却された従業員のリストの名前は、Red Hot Chili Peppers の歴代のギタリストです！RHCP は最高です。\n終わりに 公式のドキュメントでnomous Transaction Processing データベース、SpringBoot および JDBCに設定方法が記載されていますが、xml に設定を記載するのではなくapplication.propertiesに設定を寄せてみました。同じような設定をしたい方に参考になれば幸いです。\n参考  nomous Transaction Processing データベース、SpringBoot および JDBC  ","ref":"/blog/blog/20201005/"},{"title":"carbonara","date":"","description":"","body":"始めに 先日、合羽橋道具街を散策してチーズグレーターを購入しました。折角グレーターを買ったことだし、ハードチーズを削って本格的なカルボナーラを作ってみました。今回は僕のカルボナーラのレシピ紹介の記事です。簡単に真似できるのでぜひ真似してみてください！\n材料紹介（一人前）  水：1L 塩：10g パスタ（1.7mm）：80 ~ 100g ピュアオリーブオイル：15ml パンチェッタ：30g 卵黄：1 個 チーズ：好きなものを好きなだけ（今回は大さじ 1 強強） 生クリーム：15ml 牛乳：15ml ブラックペッパー：好きなだけ（今回は 20 カリカリ）  作り方・考え方 パスタをゆでるお湯について 材料紹介でも書きましたが、\n 水：1L 塩：10g  と塩分濃度 1%のお湯で茹でています。一人前に対して最低でも 1L くらいのお湯で茹でたほうがいいです。今回は 1%の塩分濃度のお湯でパスタを茹でていますが、他に塩気を足すような食材（今回だとチーズとパンチェッタ）がない場合は 1.4%くらいで茹でます。 また、カルボナーラの場合は麺の太さにも依存しますが表記時間の 1 分半前にあげます。\nパンチェッタを炒める パンチェッタをカリカリになるまで炒めていきます。カリカリと言っても、外がカリカリで中は肉感が残っているくらいです。本当のカリカリにするとただのだしがらになります。目安としては下の写真くらいです。\nパンチェッタなのか、ベーコンなのか 正直どっちでも良いと思っています。伝統的なレシピだとパンチェッタなのでしょうが、ベーコンの薫香がするカルボナーラもそれはそれで非常においしいです。自分の好きな方を選んだらいいと思います。\nゆで汁を加える 個人的にはこの工程がカルボナーラボソボソ事件を防ぐうえで一番大切なんじゃないかと思っています。ゆで汁を先ほど炒めたフライパンに加えるのですが、おそらく想像しているよりも加えます。今回は、45ml 加えています。ゆで汁を加えたら火を止めておきます。\n大体これくらい。結構しゃばい。\n和食の茶碗蒸しと考え方は同じで、たっぷりの出汁（ゆで汁、パンチェッタ、オイル）と卵（卵黄、チーズ、牛乳、生クリーム）で卵液を作るってことです。\nカルボナーラの素を作る 以下の材料を適当なボールなどで混ぜておきます。\n 卵黄 牛乳 生クリーム チーズ ブラックペッパー  好みにもよりますが、チーズは旨味の強いチーズ（パルミジャーノ・レッジャーノ、ペコリーノ・ロマーノ、グラナ・パダーノ）がおすすめです。今回は、チーズのこえで購入したナチュラルチーズを使用しました。（とっても美味しいです！）\nまた、ブラックペッパーは最低でも 15~20 カリカリくらいは欲しいですね。\n茹で上がった麺をフライパンにいれる 茹で上がり 30 秒前程度になったら火をつけ、フライパンの中を沸かします。沸いた中にパスタを入れてよく和えて火を止めます。\nカルボナーラの素投入 火から降ろしたフライパンにカルボナーラの素を加えます。ゆで汁をかなり加えているのでそんなに焦らなくても大丈夫ですが、良くかき混ぜます。\nちなみに、カルボナーラの素を加えてよく混ぜた後はこんな感じです。かなりしゃばいですね。この状態で店で出てきたら二度と行かないレベルです。\nよく混ぜた後に火をつけ加熱によって卵のコクを出していきます。目指すは旅館の朝ごはんで出てくる温泉卵の黄身の状態です。ゆっくりと加熱しこれくらいの粘度になったらおっけーです！ここで加熱するからパスタの茹で時間を表記の 1 分半前にしたってことですね。\n完成 美味そうに盛り付け、追いチーズと追いブラックペッパーをして完成です！クリーム系のパスタは冷めると途端にまずくなるのでさっさと食べます。\n終わりに 今回買ったグレーターです。\n ","ref":"/blog/blog/20200927/"},{"title":"僕が転職活動をどのように行っていたか","date":"","description":"","body":"始めに 2020 年 4 月頃からいい所があったら転職しようと緩く転職活動をしていましたが、8 月にとある会社さんから内定をいただき転職活動を終了することにしました。若手（新卒 3 年目）かつ、コロナ禍の転職活動ということで同じような境遇の方に参考となれば幸いです。\n前提（私のこと） 簡単に自己紹介をします。\n SIer で新卒 3 年目  共通技術部門（いわゆる何でも屋さん）に所属  自社 FW の開発、保守 特定プロジェクトへの技術支援     技術スタック  言語  Java  Spring etc \u0026hellip;   Node.js, TypeScript  Nest.js, Angular etc \u0026hellip;     Database  Oracle, PostgreSQL, MongoDB など一応触れる程度   クラウド関連  AWS      簡単に転職活動を振り返ってみる 活動の頻度 ひと月に 1~2 社（多くても 3 社）くらいしかエントリーしていなかったです。0 社の時とかも普通にありました。母数をもっと打った方が内定をいただく可能性が高くなることも分かっていたのですが、いくつかの理由でこのペースで実施していました。\n 現状に不満はあったが、やめるほどではなかった。 行きたくない（自分のやりたい事と異なる）所に出すつもりが全くなかった。  1. 現状に不満はあったが、やめるほどではなかった 「じゃあ、やめなきゃいいじゃん！」と声が飛んできそうですが、やりたいことをやるために、会社外により良い環境があるということは分かっていました。そういった意味で今回の転職は半分チャレンジのつもりで動いていました。\n2. 行きたくない（自分のやりたい事と異なる）所に出すつもりが全くなかった これも上の理由に同じです。極端な話、失敗してもいいやと思っていた転職活動だったので、若造ながらかなり強気に選んでいました。\n「私の経験上、20 社にエントリーして内定もらえるのが 1~2 社なので最低でも 20 社はエントリーしてくださいね！」と大量の企業リストを渡してきたエージェントさんには申し訳ないですが、それ以降返事をすることはなかったです。\nTwitter などでそんなエージェントいるのか！？と時たま流れるツイートを観測していましたが、実際に活動をしてみると割合としては少ないですが、確かにいました。\nやっていたこと とは言っても、エントリーさせていただいた企業様で働きたい気持ちは強かったので、それなりに準備や対策？はしていました。\n CV（職務経歴書）のバージョン管理 面接後の振り返り 継続的なアウトプット  1. CV（職務経歴書）のバージョン管理 自分が楽をするために実施していました。Word ではなく、Markdown で書いて GitLab Pages にホスティングしていました。我ながら結構いい取り組みだったなと思っていたので概要を紹介します。詳細は以前執筆した Qiita の記事（職務経歴書を GitLab Pages を使って公開してみた）を参照してください。\n概要  CV は、Markdown で書き GitLab でバージョン管理 リポジトリにはパイプラインが設定してあり、master ブランチにプッシュされるごとに以下の事を実施していた。  GitBookを使用して、MarkDown -\u0026gt; HTML, PDF へと変換  HTML；GitLab Pages にホスティング PDF；Artifact として、ダウンロードしそのまま提出      お勧めしたい点  エージェントさんと電話面談するときやカジュアル面談の時もとりあえず URL を渡せば、CV を共有できた。  LinkedIn で声を掛けられ、とりあえず話だけでも聞いてみるかという時には結構重宝しました。   後述する振り返りがやりやすかった。 GitHub/GitLab に草を生やせる。（FindyやLAPLASを使用している方にとっては良いことなのではないでしょうか？）  2. 面接後の振り返り 面接後、忘れないうちに自分が上手く答えられなかった質問を企業毎に起票していた Issue に記載していきます。（もちろん、自分しか見れないようにconfidentialな Issue としていた。）\n技術的な質問をされて答えられなかったことや、面接後のフィードバックで言われたことなど、次に繋がりそうな事はとりあえずメモしていました。\n3. 継続的なアウトプット 転職活動に関係なく、普段から定期的？にブログを書いたり、コードを書いたりなどをしていますが、そう言った点を評価してくれる事も多かったです。後は、単純に学習の効率が良くなるのでやったほうがいいと思います。\n使っていた転職サービス 色々お試ししましたが、最終的にLinkedInのみ使用していました。声をかけてくれた企業の人事の方やエージェントの方とその都度会話するって感じです。ノイズのような情報が他の転職サービスに比べて少ないと感じたことが決め手でした。\nコロナ禍での転職活動は実際どうだったのか 書類で門前払いされたりポテンシャル採用（教育を前提とした採用）だったら良かったのに、、と言われることもありましたが、騒ぐほど厳しい転職市場だったのかな？と思っています。未経験者には確かに厳しいかもしれませんが、経験者であれば余り変わらないのかなと。 強いて言うなら、落とされることには、きちんと理由があってそれをちゃんと分析し次に活かすという事がより重要だったように思えます。（コロナ禍前に活動していないので比較はできませんがw）\n終わりに 駄文を読んでいただきありがとうございます。一個人の意見なので当てになるかは分かりませんが、参考になれば幸いです。\n","ref":"/blog/blog/20200915/"},{"title":"Nest.jsで接続先情報を環境変数から非同期で取得する","date":"","description":"","body":"始めに ※ブログを一か所にまとめるため、以前Qiitaに投稿した記事の移行しています。\nNest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。\n環境  Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6  実装手順 必要最小限の実装 参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt;Database\nライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。\n$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ItemModule } from \u0026#39;./item/item.module\u0026#39;; import { Connection } from \u0026#39;typeorm\u0026#39;; import { join } from \u0026#39;path\u0026#39;; @Module({ imports: [ ItemModule, // DBの接続情報を定義  TypeOrmModule.forRoot({ type: \u0026#39;postgres\u0026#39;, host: \u0026#39;localhost\u0026#39;, port: 5432, username: \u0026#39;postgres\u0026#39;, password: \u0026#39;postgres\u0026#39;, database: \u0026#39;postgres\u0026#39;, entities: [join(__dirname + \u0026#39;/**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }), ], }) export class AppModule {} 一番シンプルな書き方です。自分一人しか触らず、環境もこれだけ！ということであればこの書き方で良いでしょう。\nしかし、実際の開発では個人の開発環境、テスト環境、ステージング環境、本番環境と複数の環境が存在し、上記のような実装では環境ごとに接続情報をハードコードし直し → ビルド → デプロイという手順を踏む必要がありナンセンスです。\nそのため、通常は環境変数に定義し、接続情報はその環境変数を参照し作成します。\nと、いうことで環境変数を参照するようにapp.module.tsを修正します。\n【失敗】環境変数を参照するように実装を修正 ※この方法では実行時に依存関係が解決できずエラーとなります。\n参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt; Configuration\nライブラリインストール 環境変数を参照するために必要なライブラリをインストールします。\n$ npm install @nestjs/config ダミーの環境変数を用意 本来は、環境変数に定義するのですがサンプル実装なので環境変数ファイル（.env）をプロジェクトルートに作成します。\nDATABASE_HOST=localhost DATABASE_PORT=5432 DATABASE_USERNAME=postgres DATABASE_PASSWORD=postgres DATABASE_NAME=postgres 環境変数を参照するように接続定義を修正 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ConfigModule, ConfigService } from \u0026#39;@nestjs/config\u0026#39;; import { Connection } from \u0026#39;typeorm\u0026#39;; import { join } from \u0026#39;path\u0026#39;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#39;.env\u0026#39;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), // 非同期で環境変数から値を取得し、接続情報を作成する。  TypeOrmModule.forRootAsync({ imports: [ConfigModule], useFactory: async (configService: ConfigService) =\u0026gt; ({ type: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, host: configService.get(\u0026#39;DATABASE_HOST\u0026#39;), port: Number(configService.get(\u0026#39;DATABASE_HOST\u0026#39;)), username: configService.get(\u0026#39;DATABASE_USERNAME\u0026#39;), password: configService.get(\u0026#39;DATABASE_PASSWORD\u0026#39;), database: configService.get(\u0026#39;DATABASE_NAME\u0026#39;), entities: [join(__dirname + \u0026#39;/**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }), inject: [ConfigService], }), ], }) export class AppModule { constructor(private readonly connection: Connection) {} } 起動後、以下のエラーが発生。\n2:25:34 PM - Found 0 errors. Watching for file changes. [Nest] 19111 - 01/13/2020, 2:25:35 PM [NestFactory] Starting Nest application... [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] TypeOrmModule dependencies initialized +24ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] ConfigModule dependencies initialized +1ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [ExceptionHandler] Nest can't resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) +1ms Error: Nest can't resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) at Injector.lookupComponentInExports (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:185:19) at processTicksAndRejections (internal/process/task_queues.js:94:5) at async Injector.resolveComponentInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:142:33) at async resolveParam (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:96:38) at async Promise.all (index 0) at async Injector.resolveConstructorParams (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:111:27) at async Injector.loadInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:78:9) at async Injector.loadProvider (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:35:9) at async Promise.all (index 3) at async InstanceLoader.createInstancesOfProviders (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/instance-loader.js:41:9) 環境変数を参照するためのConfigServiceがTypeOrmModuleOptions内で依存関係が解決できないことが原因らしい。\n同じような事象が Github の Issue にあがっていたので参考に載せておきます。\nCan\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n【成功】環境変数を参照するように実装を修正 app.module.tsを以下のように修正します。\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ConfigModule } from \u0026#39;@nestjs/config\u0026#39;; import { TypeOrmConfigService } from \u0026#39;./common/database/type-orm-config.service\u0026#39;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#39;.env\u0026#39;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), TypeOrmModule.forRootAsync({ imports: [ConfigModule], // 接続情報を作成するServiceクラスを定義  useClass: TypeOrmConfigService, }), ], }) export class AppModule { } 接続情報を作成するServiceクラスを生成します。\nimport { TypeOrmOptionsFactory, TypeOrmModuleOptions } from \u0026#39;@nestjs/typeorm\u0026#39;; import { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { ConfigService } from \u0026#39;@nestjs/config\u0026#39;; import { join } from \u0026#39;path\u0026#39;; /** * DBの接続情報を作成するServiceクラスです。 */ @Injectable() export class TypeOrmConfigService implements TypeOrmOptionsFactory { /** * DBの接続設定を環境変数をもとに作成します。 * 環境変数に設定されていない場合は、デフォルトの設定値を返却します。 * @returns 接続情報 */ createTypeOrmOptions(): TypeOrmModuleOptions { const configService = new ConfigService(); return { type: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, host: configService.get(\u0026#39;DATABASE_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), port: Number(configService.get(\u0026#39;DATABASE_PORT\u0026#39;, 5432)), username: configService.get(\u0026#39;DATABASE_USERNAME\u0026#39;, \u0026#39;postgres\u0026#39;), password: configService.get(\u0026#39;DATABASE_PASSWORD\u0026#39;, \u0026#39;postgres\u0026#39;), database: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, entities: [join(__dirname + \u0026#39;../**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }; } } ConfigServiceを DI するのではなく、自分で new するのがポイントです。\n最後に 今回のサンプル実装はこちらのリポジトリで公開しています。\n最近使い始めたのですが、素晴らしいフレームワークだとひしひしと感じております。 フレームワーク自体の良さはこちらの記事で紹介されています。\n参考   NestJs 公式ドキュメント\n  Can\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n  Nest.js は素晴らしい\n  ","ref":"/blog/blog/20200911/"},{"title":"Hugo + GitHub Pagesでブログを始めた","date":"","description":"","body":"始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。\nこのブログについて 環境  静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages  という環境で、作成し運用されています。\n選定理由 いくつか背景があるので、順にお話します。\nQiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。\n静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc \u0026hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。\nホスティング先 ホスティング先には、いくつか条件がありました。\n 無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと  これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。\ndocs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。\n\u0026gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.co/NCVgnMOonq\n\u0026mdash; peaceiris (@piris314) September 6, 2020  どうやら、Hugo で生成されるファイル群をバージョン管理する方法ではなく、GitHub Actinos で静的ファイルを任意のブランチに生成し、そのブランチを GitHub Pages へデプロイするという方法があるようです。\nブログの作り方 前置きが長くなってしまいましたが、当ブログの作り方を簡単に説明したいと思います。\n 省エネ、基本的に無料でブログを書きたい人 自分でデザインしないと満足できない人  には、お勧めできる方法だと思います。尚、テーマのカスタマイズや自作方法については当記事では触れないので悪しからず。\n環境構築 Windows 10 を使用しています。Chocolatey, Scoop といったパッケージマネージャーを使用する方法と zip を展開してパスを通す方法がありますが、今回紹介するのは後者の方法です。\nhttps://github.com/gohugoio/hugo/releasesから最新版の zip ファイルをダウンロードし適用なディレクトリに解凍します。\n同じバージョンでも通常版（hugo）と Extended 版（hugo_extended）と 2 種類ありますが、後ほど紹介する公開されているテーマを使用する場合はExtended 版の方を選択してください。（Extended 版の方は、SASS/SCSS が使用できます。公開されているテーマで SASS/SCSS が使用されている場合、通常の hugo ではエラーが発生し静的ファイルの生成ができません。）\n次に、パスを通します。システム環境変数からPathを選択し、先ほど解凍したディレクトリを指定します。\n$ hugo version Hugo Static Site Generator v0.74.3/extended windows/amd64 BuildDate: unknown この様に表示されれば、環境構築は完了です。\nブログを生成する 適当なディレクトリで以下のように入力する。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Git\\test\\blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation. テーマを選定する https://themes.gohugo.io/にいい感じのテーマが沢山あるので好きなものを選びます。（ここでは仮に、Hugo Future Imperfect Slimを選択したとする）Download ボタンを押すと、GitHub のリポジトリトップに遷移するので、README を読みながら設定を進めます。\nテーマのインストール テーマは Git の Submodule として管理するのが主流みたいです。\n$ cd blog/themes $ git submodule add https://github.com/pacollins/hugo-future-imperfect-slim.git $ git submodule update --remote --merge 設定ファイルをコピーし修正する サンプルサイトの設定ファイル（config.toml, staticman.yml）を自サイトのルートにコピーします。\n$ cp ./hugo-future-imperfect-slim/exampleSite/config.toml ../ $ cp ./hugo-future-imperfect-slim/exampleSite/staticman.yml ../ この手の設定は、自分で動かしながら変えていくのが手っ取り早いかなと思いました。（分からない所だけドキュメントを参照する）\nGitHub Pages で公開する .github/workflows/gh-pages.ymlを作成する。詳細な説明は、リポジトリを参照してください。\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.74.2\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 後は、master に push すればhttps://\u0026lt;github username\u0026gt;.github.io/\u0026lt;repository name\u0026gt;として公開されます！\n終わりに 細かい個所などは紹介できていないので、詳細が気になる方はリポジトリを参照してください。\n参考  https://gohugo.io/ https://github.com/peaceiris/actions-hugo https://github.com/shukawam/blog  ","ref":"/blog/blog/20200909/"}]