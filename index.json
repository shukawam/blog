[{"title":"TODO: あとで考える","date":"","description":"","body":"始めに 今回は、Java の軽量フレームワークの一つである Helidon を触ってみたいと思います。尚、Helidon には\n Helidon SE: 軽量でフットプリント重視 Helidon MP: Eclipse MicroProfile との互換性や機能性を重視  と、エディションが二つ存在しますが、一旦は SE の方に注目して触っていきたいと思います。(SE のコンポーネントを一通り試し終わったら、MP も同様に試していきます。)\n終わりに 参考 ","ref":"/blog/blog/2021/0206-helidon-se-get-started/"},{"title":"Nest.jsで接続先情報を環境変数から非同期で取得する","date":"","description":"","body":"始めに ※ブログを一か所にまとめるため、以前Qiitaに投稿した記事の移行しています。\nNest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。\n環境  Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6  実装手順 必要最小限の実装 参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt;Database\nライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。\n$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ItemModule } from \u0026#39;./item/item.module\u0026#39;; import { Connection } from \u0026#39;typeorm\u0026#39;; import { join } from \u0026#39;path\u0026#39;; @Module({ imports: [ ItemModule, // DBの接続情報を定義  TypeOrmModule.forRoot({ type: \u0026#39;postgres\u0026#39;, host: \u0026#39;localhost\u0026#39;, port: 5432, username: \u0026#39;postgres\u0026#39;, password: \u0026#39;postgres\u0026#39;, database: \u0026#39;postgres\u0026#39;, entities: [join(__dirname + \u0026#39;/**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }), ], }) export class AppModule {} 一番シンプルな書き方です。自分一人しか触らず、環境もこれだけ！ということであればこの書き方で良いでしょう。\nしかし、実際の開発では個人の開発環境、テスト環境、ステージング環境、本番環境と複数の環境が存在し、上記のような実装では環境ごとに接続情報をハードコードし直し → ビルド → デプロイという手順を踏む必要がありナンセンスです。\nそのため、通常は環境変数に定義し、接続情報はその環境変数を参照し作成します。\nと、いうことで環境変数を参照するようにapp.module.tsを修正します。\n【失敗】環境変数を参照するように実装を修正 ※この方法では実行時に依存関係が解決できずエラーとなります。\n参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt; Configuration\nライブラリインストール 環境変数を参照するために必要なライブラリをインストールします。\n$ npm install @nestjs/config ダミーの環境変数を用意 本来は、環境変数に定義するのですがサンプル実装なので環境変数ファイル（.env）をプロジェクトルートに作成します。\nDATABASE_HOST=localhost DATABASE_PORT=5432 DATABASE_USERNAME=postgres DATABASE_PASSWORD=postgres DATABASE_NAME=postgres 環境変数を参照するように接続定義を修正 import { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ConfigModule, ConfigService } from \u0026#39;@nestjs/config\u0026#39;; import { Connection } from \u0026#39;typeorm\u0026#39;; import { join } from \u0026#39;path\u0026#39;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#39;.env\u0026#39;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), // 非同期で環境変数から値を取得し、接続情報を作成する。  TypeOrmModule.forRootAsync({ imports: [ConfigModule], useFactory: async (configService: ConfigService) =\u0026gt; ({ type: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, host: configService.get(\u0026#39;DATABASE_HOST\u0026#39;), port: Number(configService.get(\u0026#39;DATABASE_HOST\u0026#39;)), username: configService.get(\u0026#39;DATABASE_USERNAME\u0026#39;), password: configService.get(\u0026#39;DATABASE_PASSWORD\u0026#39;), database: configService.get(\u0026#39;DATABASE_NAME\u0026#39;), entities: [join(__dirname + \u0026#39;/**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }), inject: [ConfigService], }), ], }) export class AppModule { constructor(private readonly connection: Connection) {} } 起動後、以下のエラーが発生。\n2:25:34 PM - Found 0 errors. Watching for file changes. [Nest] 19111 - 01/13/2020, 2:25:35 PM [NestFactory] Starting Nest application... [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] TypeOrmModule dependencies initialized +24ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] ConfigModule dependencies initialized +1ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [ExceptionHandler] Nest can't resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) +1ms Error: Nest can't resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) at Injector.lookupComponentInExports (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:185:19) at processTicksAndRejections (internal/process/task_queues.js:94:5) at async Injector.resolveComponentInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:142:33) at async resolveParam (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:96:38) at async Promise.all (index 0) at async Injector.resolveConstructorParams (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:111:27) at async Injector.loadInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:78:9) at async Injector.loadProvider (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:35:9) at async Promise.all (index 3) at async InstanceLoader.createInstancesOfProviders (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/instance-loader.js:41:9) 環境変数を参照するためのConfigServiceがTypeOrmModuleOptions内で依存関係が解決できないことが原因らしい。\n同じような事象が Github の Issue にあがっていたので参考に載せておきます。\nCan\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n【成功】環境変数を参照するように実装を修正 app.module.tsを以下のように修正します。\nimport { Module } from \u0026#39;@nestjs/common\u0026#39;; import { TypeOrmModule } from \u0026#39;@nestjs/typeorm\u0026#39;; import { ConfigModule } from \u0026#39;@nestjs/config\u0026#39;; import { TypeOrmConfigService } from \u0026#39;./common/database/type-orm-config.service\u0026#39;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#39;.env\u0026#39;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), TypeOrmModule.forRootAsync({ imports: [ConfigModule], // 接続情報を作成するServiceクラスを定義  useClass: TypeOrmConfigService, }), ], }) export class AppModule { } 接続情報を作成するServiceクラスを生成します。\nimport { TypeOrmOptionsFactory, TypeOrmModuleOptions } from \u0026#39;@nestjs/typeorm\u0026#39;; import { Injectable } from \u0026#39;@nestjs/common\u0026#39;; import { ConfigService } from \u0026#39;@nestjs/config\u0026#39;; import { join } from \u0026#39;path\u0026#39;; /** * DBの接続情報を作成するServiceクラスです。 */ @Injectable() export class TypeOrmConfigService implements TypeOrmOptionsFactory { /** * DBの接続設定を環境変数をもとに作成します。 * 環境変数に設定されていない場合は、デフォルトの設定値を返却します。 * @returns 接続情報 */ createTypeOrmOptions(): TypeOrmModuleOptions { const configService = new ConfigService(); return { type: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, host: configService.get(\u0026#39;DATABASE_HOST\u0026#39;, \u0026#39;localhost\u0026#39;), port: Number(configService.get(\u0026#39;DATABASE_PORT\u0026#39;, 5432)), username: configService.get(\u0026#39;DATABASE_USERNAME\u0026#39;, \u0026#39;postgres\u0026#39;), password: configService.get(\u0026#39;DATABASE_PASSWORD\u0026#39;, \u0026#39;postgres\u0026#39;), database: \u0026#39;postgres\u0026#39; as \u0026#39;postgres\u0026#39;, entities: [join(__dirname + \u0026#39;../**/*.entity{.ts,.js}\u0026#39;)], synchronize: false, }; } } ConfigServiceを DI するのではなく、自分で new するのがポイントです。\n最後に 今回のサンプル実装はこちらのリポジトリで公開しています。\n最近使い始めたのですが、素晴らしいフレームワークだとひしひしと感じております。 フレームワーク自体の良さはこちらの記事で紹介されています。\n参考   NestJs 公式ドキュメント\n  Can\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n  Nest.js は素晴らしい\n  ","ref":"/blog/blog/2020/0911-nestjs-async-multiple-db-connection/"},{"title":"Hugo + GitHub Pagesでブログを始めた","date":"","description":"","body":"始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。\nこのブログについて 環境  静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages  という環境で、作成し運用されています。\n選定理由 いくつか背景があるので、順にお話します。\nQiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。\n静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc \u0026hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。\nホスティング先 ホスティング先には、いくつか条件がありました。\n 無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと  これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。\ndocs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。\n\u0026gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.co/NCVgnMOonq\n\u0026mdash; peaceiris (@piris314) September 6, 2020  どうやら、Hugo で生成されるファイル群をバージョン管理する方法ではなく、GitHub Actinos で静的ファイルを任意のブランチに生成し、そのブランチを GitHub Pages へデプロイするという方法があるようです。\nブログの作り方 前置きが長くなってしまいましたが、当ブログの作り方を簡単に説明したいと思います。\n 省エネ、基本的に無料でブログを書きたい人 自分でデザインしないと満足できない人  には、お勧めできる方法だと思います。尚、テーマのカスタマイズや自作方法については当記事では触れないので悪しからず。\n環境構築 Windows 10 を使用しています。Chocolatey, Scoop といったパッケージマネージャーを使用する方法と zip を展開してパスを通す方法がありますが、今回紹介するのは後者の方法です。\nhttps://github.com/gohugoio/hugo/releasesから最新版の zip ファイルをダウンロードし適用なディレクトリに解凍します。\n同じバージョンでも通常版（hugo）と Extended 版（hugo_extended）と 2 種類ありますが、後ほど紹介する公開されているテーマを使用する場合はExtended 版の方を選択してください。（Extended 版の方は、SASS/SCSS が使用できます。公開されているテーマで SASS/SCSS が使用されている場合、通常の hugo ではエラーが発生し静的ファイルの生成ができません。）\n次に、パスを通します。システム環境変数からPathを選択し、先ほど解凍したディレクトリを指定します。\n$ hugo version Hugo Static Site Generator v0.74.3/extended windows/amd64 BuildDate: unknown この様に表示されれば、環境構築は完了です。\nブログを生成する 適当なディレクトリで以下のように入力する。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Git\\test\\blog. Just a few more steps and you're ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026quot;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026quot; command. 2. Perhaps you want to add some content. You can add single files with \u0026quot;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026quot;. 3. Start the built-in live server via \u0026quot;hugo server\u0026quot;. Visit https://gohugo.io/ for quickstart guide and full documentation. テーマを選定する https://themes.gohugo.io/にいい感じのテーマが沢山あるので好きなものを選びます。（ここでは仮に、Hugo Future Imperfect Slimを選択したとする）Download ボタンを押すと、GitHub のリポジトリトップに遷移するので、README を読みながら設定を進めます。\nテーマのインストール テーマは Git の Submodule として管理するのが主流みたいです。\n$ cd blog/themes $ git submodule add https://github.com/pacollins/hugo-future-imperfect-slim.git $ git submodule update --remote --merge 設定ファイルをコピーし修正する サンプルサイトの設定ファイル（config.toml, staticman.yml）を自サイトのルートにコピーします。\n$ cp ./hugo-future-imperfect-slim/exampleSite/config.toml ../ $ cp ./hugo-future-imperfect-slim/exampleSite/staticman.yml ../ この手の設定は、自分で動かしながら変えていくのが手っ取り早いかなと思いました。（分からない所だけドキュメントを参照する）\nGitHub Pages で公開する .github/workflows/gh-pages.ymlを作成する。詳細な説明は、リポジトリを参照してください。\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.74.2\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 後は、master に push すればhttps://\u0026lt;github username\u0026gt;.github.io/\u0026lt;repository name\u0026gt;として公開されます！\n終わりに 細かい個所などは紹介できていないので、詳細が気になる方はリポジトリを参照してください。\n参考  https://gohugo.io/ https://github.com/peaceiris/actions-hugo https://github.com/shukawam/blog  ","ref":"/blog/blog/2020/0909-about-this-blog/"}]