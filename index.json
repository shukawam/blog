[{"title":"Helidon SE Component - Config, OpenAPI","date":"","description":"","body":"始めに Java の軽量フレームワークの一つであるHelidonの全コンポーネントを触っていくエントリーの一回目です。本日は、\n Config OpenAPI  について触っていこうと思います。\nComponents Config  様々なソース(.properties, .yaml, .json)から Config オブジェクトに設定プロパティをロードして処理するための Java API を提供します 各種設定情報をソースコードから分離することでコード自体の保守性を向上させたりする目的があります  早速、試していきます。CLI を使用してひな形を生成した場合は、自動的に Config 関連の依存関係が含まれていますが、含まれていない場合は以下をpom.xmlに追加します。\npom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.config\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-config-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 今回は、yaml形式で記載したいと思います。jsonでもpropertiesでも結果は同じですが個人的にyamlが好きだからです。（一番無駄がないし、視認性もよい）\nresources/application.yamlに Config オブジェクトにマッピングさせる情報を記載していきます。\napplication.yaml\napp: greeting: \u0026#34;Hello\u0026#34; config: \u0026#34;config service works!!\u0026#34; # 追記 server: port: 8080 host: 0.0.0.0 application.yamlに記載した項目を参照するには以下のようにします。\nvar config = Config.create(); var value = config.get(\u0026#34;app.config\u0026#34;).asString().orElse(\u0026#34;config service NOT work\u0026#34;); OpenAPI  OpenAPI 仕様のドキュメントを生成するエンドポイントを容易に生成することができる Eclipse MicroProfile の OpenAPI 仕様となっているので、実装などで困った際は Helidon のドキュメントではなく、MicroProfile の OpenAPI 仕様のドキュメントを参考にするとよい  早速、試していきます。まずは、OpenAPI 関連の依存関係をpom.xmlに追加します。\npom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.openapi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-openapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OpenAPISupportをサーバの設定に追加します。\nreturn Routing.builder() // ...  // OpenAPI support  .register(OpenAPISupport.create(config)) .build(); OpenAPI ドキュメントを構築するためにいくつか手段があります。\n  OpenAPI の定義ファイルを作成する\n META-INF/openapi.yml, META-INF/openapi.yaml, META-INF/openapi.json に定義を追加する    org.eclipse.microprofile.openapi.OASModelReaderインタフェースを実装した Java クラスに定義を記述する\n  1. OpenAPI の定義ファイルを作成する 今回は、以下のようなサンプルファイルを生成しました。\nopenapi.yaml\nopenapi: 3.0.0 info: title: Helidon SE OpenAPI Example. description: helidon se openapi example. version: 1.0.0 servers: - url: http://localhost:8080 description: Local server. components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string paths: /greet: get: summary: Returns a generic greeting description: Greets the user generically responses: \u0026#34;200\u0026#34;: description: OK content: application/json: examples: Greet: value: message: Hello World! /config: get: summary: Returns a config properties. description: return a config properties. responses: \u0026#34;200\u0026#34;: description: OK content: application/json: examples: Config: value: message: config service works!! API 仕様のエンドポイントは/openapiとなっているため、特にヘッダー情報を追加せずにリクエストを送るとYAML形式のデータ(上記の定義ファイルと同じ内容)を返却します。\nservers: - description: Local server. url: http://localhost:8080 components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string info: description: helidon se openapi example. title: Helidon SE OpenAPI Example. version: 1.0.0 openapi: 3.0.0 paths: /greet: get: description: Greets the user generically responses: \u0026#34;200\u0026#34;: content: application/json: examples: Greet: value: message: Hello World! description: OK summary: Returns a generic greeting /config: get: description: return a config properties. responses: \u0026#34;200\u0026#34;: content: application/json: examples: Config: value: message: config service works!! description: OK summary: Returns a config properties. ちなみに、ドキュメントを取得するパスを変更したい場合は以下のように設定を変更します。\napplication.yaml\nopenapi: web-context: /myopenapi # 任意のパスに変更可能 2. org.eclipse.microprofile.openapi.OASModelReaderインタフェースを実装した Java クラスに定義を記述する まずは、設定ファイルにOASModelReaderを使用することを記述します。具体的には以下のように。\napplication.yaml\n# OpenAPI configuration. openapi: model: reader: shukawam.examples.helidon.se.openapi.OpenAPIModelReader さて、実装クラスですが今回は以下のように実装してみました。\npublic class OpenAPIModelReader implements OASModelReader { // OASModelReaderの実装クラスを作成する  private static final String MODEL_READER_PATH = \u0026#34;/openapi/test\u0026#34;; private static final String DESCRIPTION = \u0026#34;A sample endpoint from OASModelReader.\u0026#34;; @Override public OpenAPI buildModel() { PathItem pathItem = OASFactory.createPathItem() .GET(OASFactory.createOperation() .operationId(\u0026#34;test\u0026#34;) .description(DESCRIPTION) ); OpenAPI openAPI = OASFactory.createOpenAPI(); Paths paths = OASFactory.createPaths() .addPathItem(MODEL_READER_PATH, pathItem); openAPI.paths(paths); return openAPI; } } そのうえで先ほどのエンドポイントに対してリクエストを送ってみると、\nservers: - description: Local server. url: http://localhost:8080 components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string info: description: helidon se openapi example. title: Helidon SE OpenAPI Example. version: 1.0.0 openapi: 3.0.0 paths: /openapi/test: # OASModelReaderの実装クラスで追加した情報が返却される get: description: A sample endpoint from OASModelReader. operationId: test /greet: get: description: Greets the user generically responses: \u0026#34;200\u0026#34;: content: application/json: examples: Greet: value: message: Hello World! description: OK summary: Returns a generic greeting /config: get: description: return a config properties. responses: \u0026#34;200\u0026#34;: content: application/json: examples: Config: value: message: config service works!! description: OK summary: Returns a config properties. これに加え、OASFilterを実装したクラスを作成し、適切な処理を実装すれば OpenAPI が内部モデルを構築する前に任意の処理を挟みこむことができます。\n終わりに 今回は、Config, OpenAPI のコンポーネントについて色々試してみました。次回は、DB Clientでも試してみようかと思います。\n参考   Helidon SE Component - Config\n  Helidon SE Component - OpenAPI\n  ","ref":"/blog/2021/0212-helidon-se-components/"},{"title":"Helidon SE Get Started","date":"","description":"","body":"始めに Java の軽量フレームワークの一つである Helidon を何回かに分けて全コンポーネントを触ってみたいと思います。尚、Helidon には\n Helidon SE: 軽量でフットプリント重視 Helidon MP: Eclipse MicroProfile との互換性や機能性を重視  と、エディションが二つ存在しますが、一旦は SE の方に注目して触っていきたいと思います。(SE のコンポーネントを一通り試し終わったら、MP も同様に試していきます。) 今回は、アプリケーションの生成までをやっていきます。\n環境 一応、私の環境情報を載せておきます。\n OS: Windows 10(WSL2 で Ubuntu 18.04 を使用しています) Java: OpenJDK 11  手順 Helidon CLI を使う アプリケーションのひな型生成や開発モード（ソースコードの変更を再度ビルドする必要なく即時反映してくれる仕組み）をサポートしている便利ツールです。2021/02/06 現在、Windows はまだ CLI の配布がされていないため、ローカルで CLI を使用したい場合は、WSL2 で Ubuntu を使うなどのひと工夫が必要です。\nインストール自体は、非常に簡単でバイナリをダウンロードしてパスが通っているところにインストールするだけで大丈夫です。\n$ curl -O https://helidon.io/cli/latest/linux/helidon $ chmod +x ./helidon $ sudo mv ./helidon /usr/local/bin/ とりあえず、どんなことができるかを見ておきます。\n$ helidon --help Usage: helidon [OPTIONS] COMMAND Helidon Project command line tool Options: -D\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; Define a system property --verbose Produce verbose output --debug Produce debug output --plain Do not use color or styles in output Commands: build Build the application dev Continuous application development info Print project information init Generate a new project version Print version information Run \u0026#39;helidon COMMAND --help\u0026#39; for more information on a command. 細かいオプションを抜きにして以下の様な操作が可能となっています。\n build  アプリケーションのビルドができる --mode=PLAIN|NATIVE|JLINKで実行可能 JAR, Native Image(要 GraalVM), jlink を使用したビルドが選択可能   dev  Helidon のアプリケーションを開発モード(ソースコードの変更を即時反映してくれる仕組み)で起動することができる   info  プロジェクトの情報を出力できる   init  プロジェクトの生成ができる 対話形式 or オプションで指定することで用途に合わせたひな型からプロジェクトを生成することができる   version  バージョン情報を出力する    では、さっそくアプリケーションを作ってみたいと思います。まずは、ミニマルな構成で作成し、今後検証したコンポーネントを随時追加していきたいと思います。\n$ helidon init --flavor SE --build MAVEN --archetype bare --groupid shukawam.examples --package shukawam.examples.helidon.se --name helidon-se-examples Using Helidon version 2.2.0 Helidon flavor (1) SE (2) MP Enter selection (Default: 1): Select archetype (1) bare | Minimal Helidon SE project suitable to start from scratch (2) quickstart | Sample Helidon SE project that includes multiple REST operations (3) database | Helidon SE application that uses the dbclient API with an in-memory H2 database Enter selection (Default: 1): Project name (Default: helidon-se-examples): Project groupId (Default: shukawam.examples): Project artifactId (Default: helidon-se-examples): Project version (Default: 1.0-SNAPSHOT): Java package name (Default: shukawam.examples.helidon.se): Switch directory to /home/kawamura/git/helidon-se-examples to use CLI Start development loop? (Default: n): Helidon CLI で生成されたアプリケーションを少し見てみると、以下の様になっています。\n$ cd helidon-se-examples $ tree . ├── README.md ├── pom.xml └── src ├── main │ ├── java │ │ └── shukawam │ │ └── examples │ │ └── helidon │ │ └── se │ │ ├── GreetService.java # 自動生成されたサービスクラス(ビジネスロジックを記載するクラス) │ │ ├── Main.java # Mainクラス(サーバの起動やルーティングの設定を行うクラス) │ │ └── package-info.java │ └── resources │ ├── META-INF │ │ └── native-image │ │ └── reflect-config.json # Native Image 化する際の設定ファイル(Reflection API 関連の設定ファイルです。詳細は、https://www.graalvm.org/reference-manual/native-image/Reflection/をどうぞ) │ ├── application.yaml # Application の設定ファイル │ └── logging.properties # ログの設定ファイル └── test └── java └── shukawam └── examples └── helidon └── se └── MainTest.java # テストコード 16 directories, 9 files 開発モードで起動してみます。\n$ helidon dev helidon dev | source file changed | rebuilding (incremental) | rebuild completed (0.3 seconds) | helidon-se-examples starting 2021.02.06 23:10:47 INFO io.helidon.common.LogConfig Thread[main,5,main]: Logging at initialization configured using classpath: /logging.properties 2021.02.06 23:10:48 INFO io.helidon.common.HelidonFeatures Thread[features-thread,5,main]: Helidon SE 2.2.0 features: [Config, Health, Metrics, WebServer] 2021.02.06 23:10:48 INFO io.helidon.webserver.NettyWebServer Thread[nioEventLoopGroup-2-1,10,main]: Channel \u0026#39;@default\u0026#39; started: [id: 0x930f8a6a, L:/0:0:0:0:0:0:0:0:8080] WEB server is up! http://localhost:8080 in 1017 milliseconds (since JVM startup). JVM が起動してからアプリケーションが起動するまでの時間を計測したいので以下のログステートメントを追記しています。\nSystem.out.println( String.format( \u0026#34;WEB server is up! http://localhost:%s in %s milliseconds (since JVM startup).\u0026#34;, // 追記  ws.port(), ManagementFactory.getRuntimeMXBean().getUptime() ) ); 折角なので、Native Image も作ってみます。今回は GraalVM の環境を作らずに Native Image を作成するため、以下の様な Dockerfile を用意します。\nDockerfile.native\n# 1st stage, build the appFROMhelidon/jdk11-graalvm-maven:20.2.0 as buildWORKDIR/helidon# Create a first layer to cache the \u0026#34;Maven World\u0026#34; in the local repository.# Incremental docker builds will always resume after that, unless you update# the pomADD pom.xml .RUN mvn package -Pnative-image -Dnative.image.skip -DskipTests# Do the Maven build!# Incremental docker builds will resume here when you change sourcesADD src srcRUN mvn package -Pnative-image -Dnative.image.buildStatic -DskipTestsRUN echo \u0026#34;done!\u0026#34;# 2nd stage, build the runtime imageFROMscratchWORKDIR/helidon# Copy the binary built in the 1st stageCOPY --from=build /helidon/target/helidon-se-examples .ENTRYPOINT [\u0026#34;./helidon-se-examples\u0026#34;]EXPOSE8080Native Image を生成します。(手元の環境に GraalVM のランタイムが入っている場合は、Helidon build --mode NATIVEで Native Image のビルドができます。)\n$ docker build -t shukawam/helidon-se-native-image:v1.0 -f Dockerfile.native . 起動してみます。\n$ docker run -p 8080:8080 shukawam/helidon-se-native-image:v1.0 02021.02.06 15:13:23 INFO io.helidon.common.LogConfig Thread[main,5,main]: Logging at runtime configured using classpath: /logging.properties 2021.02.06 15:13:23 INFO io.helidon.common.HelidonFeatures Thread[features-thread,5,main]: Helidon SE 2.2.0 features: [Config, Health, Metrics, WebServer] 2021.02.06 15:13:23 INFO io.helidon.webserver.NettyWebServer Thread[nioEventLoopGroup-2-1,10,main]: Channel \u0026#39;@default\u0026#39; started: [id: 0x4c520a0c, L:/0.0.0.0:8080] WEB server is up! http://localhost:8080 in 18 milliseconds (since JVM startup). 18ms\u0026hellip;さすがに、起動は桁違いに速いです。\nちなみに、自動生成されたpom.xml内の依存関係は以下の様になっていました。\npom.xml\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.webserver\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-webserver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.media\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-media-jsonp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.config\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-config-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.health\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-health\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.health\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-health-checks\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.metrics\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-metrics\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.webclient\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-webclient\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; マイクロサービスの実装に必要不可欠な Metrics, Health Check, Config といったライブラリは、既に含まれているので特に設定することなく、Metrics や Health Check のエンドポイントを利用可能になっています。\n# Health Check $ curl http://localhost:8080/health {\u0026#34;outcome\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;checks\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;deadlock\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;diskSpace\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;free\u0026#34;:\u0026#34;228.23 GB\u0026#34;,\u0026#34;freeBytes\u0026#34;:245060718592,\u0026#34;percentFree\u0026#34;:\u0026#34;90.93%\u0026#34;,\u0026#34;total\u0026#34;:\u0026#34;250.98 GB\u0026#34;,\u0026#34;totalBytes\u0026#34;:269490393088}},{\u0026#34;name\u0026#34;:\u0026#34;heapMemory\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;free\u0026#34;:\u0026#34;68.51 MB\u0026#34;,\u0026#34;freeBytes\u0026#34;:71841744,\u0026#34;max\u0026#34;:\u0026#34;1.54 GB\u0026#34;,\u0026#34;maxBytes\u0026#34;:1648361472,\u0026#34;percentFree\u0026#34;:\u0026#34;97.87%\u0026#34;,\u0026#34;total\u0026#34;:\u0026#34;102.00 MB\u0026#34;,\u0026#34;totalBytes\u0026#34;:106954752}}]} # Metrics $ curl http://localhost:8080/metrics --header \u0026#39;Accept:application/json\u0026#39; {\u0026#34;base\u0026#34;:{\u0026#34;classloader.loadedClasses.count\u0026#34;:3881,\u0026#34;classloader.loadedClasses.total\u0026#34;:3884,\u0026#34;classloader.unloadedClasses.total\u0026#34;:0,\u0026#34;cpu.availableProcessors\u0026#34;:8,\u0026#34;cpu.systemLoadAverage\u0026#34;:0.26,\u0026#34;gc.time;name=G1 Old Generation\u0026#34;:0,\u0026#34;gc.time;name=G1 Young Generation\u0026#34;:17,\u0026#34;gc.total;name=G1 Old Generation\u0026#34;:0,\u0026#34;gc.total;name=G1 Young Generation\u0026#34;:1,\u0026#34;jvm.uptime\u0026#34;:118654,\u0026#34;memory.committedHeap\u0026#34;:106954752,\u0026#34;memory.maxHeap\u0026#34;:1648361472,\u0026#34;memory.usedHeap\u0026#34;:38256688,\u0026#34;thread.count\u0026#34;:20,\u0026#34;thread.daemon.count\u0026#34;:15,\u0026#34;thread.max.count\u0026#34;:20},\u0026#34;vendor\u0026#34;:{\u0026#34;requests.count\u0026#34;:2,\u0026#34;requests.meter\u0026#34;:{\u0026#34;count\u0026#34;:2,\u0026#34;meanRate\u0026#34;:0.016974990693588664,\u0026#34;oneMinRate\u0026#34;:0.006394042634681005,\u0026#34;fiveMinRate\u0026#34;:0.002751971906724164,\u0026#34;fifteenMinRate\u0026#34;:0.0010423449272394232}}} Maven を使う 以下、Maven, Gradle を使う場合についても参考程度に載せておきます。\nプロジェクトを生成します。\n$ mvn -U archetype:generate -DinteractiveMode=false \\  -DarchetypeGroupId=io.helidon.archetypes \\  -DarchetypeArtifactId=helidon-quickstart-se \\  -DarchetypeVersion=2.2.0 \\  -DgroupId=io.helidon.examples \\  -DartifactId=helidon-quickstart-se \\  -Dpackage=io.helidon.examples.quickstart.se 中身を覗いてみると以下のようになっています。\n$ tree . ├── Dockerfile # 実行可能JARを生成するDockerfile ├── Dockerfile.jlink # jlinkを使用してビルドするDockerfile ├── Dockerfile.native # Native Imageを生成するDockerfile ├── README.md ├── app.yaml # Kubernetesのマニフェストファイル ├── pom.xml └── src ├── main │ ├── java │ │ └── io │ │ └── helidon │ │ └── examples │ │ └── quickstart │ │ └── se │ │ ├── GreetService.java │ │ ├── Main.java │ │ └── package-info.java │ └── resources │ ├── META-INF │ │ └── native-image │ │ └── reflect-config.json │ ├── application.yaml │ └── logging.properties └── test └── java └── io └── helidon └── examples └── quickstart └── se └── MainTest.java 18 directories, 13 files CLI から生成した時には、Kubernetes のマニフェストファイルや各種 Dockerfile は生成されなかったですが、これは便利そうですね。残りは、全て CLI から生成した場合と同じでした。\nGradle を使う Helidon のサンプルはほとんどが Maven を使用していますが、Gradle も同様に使用することができます。(推奨は、Gradle 6+)Gradle を使用してビルドしたい場合は、Helidon SE の QuickStartに含まれるbuild.gradleを参考にするとよいです。\nbuild.gradle\n/* * Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ apply plugin: \u0026#39;java\u0026#39; group = \u0026#39;io.helidon.examples\u0026#39; // 自分のアプリケーションに合わせて修正する version = \u0026#39;1.0-SNAPSHOT\u0026#39; description = \u0026#34;helidon-quickstart-se\u0026#34; // 自分のアプリケーションに合わせて修正する  sourceCompatibility = 11 targetCompatibility = 11 tasks.withType(JavaCompile) { options.encoding = \u0026#39;UTF-8\u0026#39; } ext { helidonversion = \u0026#39;2.2.0\u0026#39; } test { useJUnitPlatform() } repositories { mavenCentral() mavenLocal() } dependencies { // import Helidon BOM  implementation enforcedPlatform(\u0026#34;io.helidon:helidon-dependencies:${project.helidonversion}\u0026#34;) implementation \u0026#39;io.helidon.webserver:helidon-webserver\u0026#39; implementation \u0026#39;io.helidon.media:helidon-media-jsonp\u0026#39; implementation \u0026#39;io.helidon.config:helidon-config-yaml\u0026#39; implementation \u0026#39;io.helidon.health:helidon-health\u0026#39; implementation \u0026#39;io.helidon.health:helidon-health-checks\u0026#39; implementation \u0026#39;io.helidon.metrics:helidon-metrics\u0026#39; testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api\u0026#39; testImplementation \u0026#39;io.helidon.webclient:helidon-webclient\u0026#39; testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine\u0026#39; } // define a custom task to copy all dependencies in the runtime classpath // into build/libs/libs // uses built-in Copy task copyLibs(type: Copy) { from configurations.runtimeClasspath into \u0026#39;build/libs/libs\u0026#39; } // add it as a dependency of built-in task \u0026#39;assemble\u0026#39; copyLibs.dependsOn jar assemble.dependsOn copyLibs // default jar configuration // set the main classpath // add each jar under build/libs/libs into the classpath jar { archiveFileName = \u0026#34;${project.name}.jar\u0026#34; manifest { attributes (\u0026#39;Main-Class\u0026#39;: \u0026#39;io.helidon.examples.quickstart.se.Main\u0026#39;, // 自分のアプリケーションの構造に合わせて修正してください  \u0026#39;Class-Path\u0026#39;: configurations.runtimeClasspath.files.collect { \u0026#34;libs/$it.name\u0026#34; }.join(\u0026#39; \u0026#39;) ) } } ビルドはおなじみのコマンドで。\n$ gradle build 終わりに 今回は、プロジェクトの生成までを一通りやってみました。次回以降公式ドキュメントに記載されているコンポーネントを順番に試していきたいと思います。\n今回作成したソースコードはこちらのリポジトリに格納しています。\n参考  Helidon 公式ドキュメント  ","ref":"/blog/2021/0206-helidon-se-get-started/"},{"title":"Nest.jsで接続先情報を環境変数から非同期で取得する","date":"","description":"","body":"始めに ※ブログを一か所にまとめるため、以前 Qiita に投稿した記事の移行しています。\nNest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。\n環境  Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6  実装手順 必要最小限の実装 参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt;Database\nライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。\n$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。\nimport { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ItemModule } from \u0026#34;./item/item.module\u0026#34;; import { Connection } from \u0026#34;typeorm\u0026#34;; import { join } from \u0026#34;path\u0026#34;; @Module({ imports: [ ItemModule, // DBの接続情報を定義  TypeOrmModule.forRoot({ type: \u0026#34;postgres\u0026#34;, host: \u0026#34;localhost\u0026#34;, port: 5432, username: \u0026#34;postgres\u0026#34;, password: \u0026#34;postgres\u0026#34;, database: \u0026#34;postgres\u0026#34;, entities: [join(__dirname + \u0026#34;/**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }), ], }) export class AppModule {} 一番シンプルな書き方です。自分一人しか触らず、環境もこれだけ！ということであればこの書き方で良いでしょう。\nしかし、実際の開発では個人の開発環境、テスト環境、ステージング環境、本番環境と複数の環境が存在し、上記のような実装では環境ごとに接続情報をハードコードし直し → ビルド → デプロイという手順を踏む必要がありナンセンスです。\nそのため、通常は環境変数に定義し、接続情報はその環境変数を参照し作成します。\nと、いうことで環境変数を参照するようにapp.module.tsを修正します。\n【失敗】環境変数を参照するように実装を修正 ※この方法では実行時に依存関係が解決できずエラーとなります。\n参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt; Configuration\nライブラリインストール 環境変数を参照するために必要なライブラリをインストールします。\n$ npm install @nestjs/config ダミーの環境変数を用意 本来は、環境変数に定義するのですがサンプル実装なので環境変数ファイル（.env）をプロジェクトルートに作成します。\nDATABASE_HOST=localhost DATABASE_PORT=5432 DATABASE_USERNAME=postgres DATABASE_PASSWORD=postgres DATABASE_NAME=postgres 環境変数を参照するように接続定義を修正 import { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ConfigModule, ConfigService } from \u0026#34;@nestjs/config\u0026#34;; import { Connection } from \u0026#34;typeorm\u0026#34;; import { join } from \u0026#34;path\u0026#34;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#34;.env\u0026#34;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), // 非同期で環境変数から値を取得し、接続情報を作成する。  TypeOrmModule.forRootAsync({ imports: [ConfigModule], useFactory: async (configService: ConfigService) =\u0026gt; ({ type: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, host: configService.get(\u0026#34;DATABASE_HOST\u0026#34;), port: Number(configService.get(\u0026#34;DATABASE_HOST\u0026#34;)), username: configService.get(\u0026#34;DATABASE_USERNAME\u0026#34;), password: configService.get(\u0026#34;DATABASE_PASSWORD\u0026#34;), database: configService.get(\u0026#34;DATABASE_NAME\u0026#34;), entities: [join(__dirname + \u0026#34;/**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }), inject: [ConfigService], }), ], }) export class AppModule { constructor(private readonly connection: Connection) {} } 起動後、以下のエラーが発生。\n2:25:34 PM - Found 0 errors. Watching for file changes. [Nest] 19111 - 01/13/2020, 2:25:35 PM [NestFactory] Starting Nest application... [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] TypeOrmModule dependencies initialized +24ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] ConfigModule dependencies initialized +1ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [ExceptionHandler] Nest can\u0026#39;t resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) +1ms Error: Nest can\u0026#39;t resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) at Injector.lookupComponentInExports (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:185:19) at processTicksAndRejections (internal/process/task_queues.js:94:5) at async Injector.resolveComponentInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:142:33) at async resolveParam (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:96:38) at async Promise.all (index 0) at async Injector.resolveConstructorParams (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:111:27) at async Injector.loadInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:78:9) at async Injector.loadProvider (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:35:9) at async Promise.all (index 3) at async InstanceLoader.createInstancesOfProviders (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/instance-loader.js:41:9) 環境変数を参照するためのConfigServiceがTypeOrmModuleOptions内で依存関係が解決できないことが原因らしい。\n同じような事象が Github の Issue にあがっていたので参考に載せておきます。\nCan\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n【成功】環境変数を参照するように実装を修正 app.module.tsを以下のように修正します。\nimport { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ConfigModule } from \u0026#34;@nestjs/config\u0026#34;; import { TypeOrmConfigService } from \u0026#34;./common/database/type-orm-config.service\u0026#34;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#34;.env\u0026#34;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), TypeOrmModule.forRootAsync({ imports: [ConfigModule], // 接続情報を作成するServiceクラスを定義  useClass: TypeOrmConfigService, }), ], }) export class AppModule {} 接続情報を作成する Service クラスを生成します。\nimport { TypeOrmOptionsFactory, TypeOrmModuleOptions } from \u0026#34;@nestjs/typeorm\u0026#34;; import { Injectable } from \u0026#34;@nestjs/common\u0026#34;; import { ConfigService } from \u0026#34;@nestjs/config\u0026#34;; import { join } from \u0026#34;path\u0026#34;; /** * DBの接続情報を作成するServiceクラスです。 */ @Injectable() export class TypeOrmConfigService implements TypeOrmOptionsFactory { /** * DBの接続設定を環境変数をもとに作成します。 * 環境変数に設定されていない場合は、デフォルトの設定値を返却します。 * @returns 接続情報 */ createTypeOrmOptions(): TypeOrmModuleOptions { const configService = new ConfigService(); return { type: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, host: configService.get(\u0026#34;DATABASE_HOST\u0026#34;, \u0026#34;localhost\u0026#34;), port: Number(configService.get(\u0026#34;DATABASE_PORT\u0026#34;, 5432)), username: configService.get(\u0026#34;DATABASE_USERNAME\u0026#34;, \u0026#34;postgres\u0026#34;), password: configService.get(\u0026#34;DATABASE_PASSWORD\u0026#34;, \u0026#34;postgres\u0026#34;), database: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, entities: [join(__dirname + \u0026#34;../**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }; } } ConfigServiceを DI するのではなく、自分で new するのがポイントです。\n最後に 今回のサンプル実装はこちらのリポジトリで公開しています。\n最近使い始めたのですが、素晴らしいフレームワークだとひしひしと感じております。 フレームワーク自体の良さはこちらの記事で紹介されています。\n参考   NestJs 公式ドキュメント\n  Can\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n  Nest.js は素晴らしい\n  ","ref":"/blog/2020/0911-nestjs-async-multiple-db-connection/"},{"title":"Hugo + GitHub Pagesでブログを始めた","date":"","description":"","body":"始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。\nこのブログについて 環境  静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages  という環境で、作成し運用されています。\n選定理由 いくつか背景があるので、順にお話します。\nQiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。\n静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc \u0026hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。\nホスティング先 ホスティング先には、いくつか条件がありました。\n 無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと  これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。\ndocs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。\n\u0026gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.co/NCVgnMOonq\n\u0026mdash; peaceiris (@piris314) September 6, 2020  どうやら、Hugo で生成されるファイル群をバージョン管理する方法ではなく、GitHub Actinos で静的ファイルを任意のブランチに生成し、そのブランチを GitHub Pages へデプロイするという方法があるようです。\nブログの作り方 前置きが長くなってしまいましたが、当ブログの作り方を簡単に説明したいと思います。\n 省エネ、基本的に無料でブログを書きたい人 自分でデザインしないと満足できない人  には、お勧めできる方法だと思います。尚、テーマのカスタマイズや自作方法については当記事では触れないので悪しからず。\n環境構築 Windows 10 を使用しています。Chocolatey, Scoop といったパッケージマネージャーを使用する方法と zip を展開してパスを通す方法がありますが、今回紹介するのは後者の方法です。\nhttps://github.com/gohugoio/hugo/releasesから最新版の zip ファイルをダウンロードし適用なディレクトリに解凍します。\n同じバージョンでも通常版（hugo）と Extended 版（hugo_extended）と 2 種類ありますが、後ほど紹介する公開されているテーマを使用する場合はExtended 版の方を選択してください。（Extended 版の方は、SASS/SCSS が使用できます。公開されているテーマで SASS/SCSS が使用されている場合、通常の hugo ではエラーが発生し静的ファイルの生成ができません。）\n次に、パスを通します。システム環境変数からPathを選択し、先ほど解凍したディレクトリを指定します。\n$ hugo version Hugo Static Site Generator v0.74.3/extended windows/amd64 BuildDate: unknown この様に表示されれば、環境構築は完了です。\nブログを生成する 適当なディレクトリで以下のように入力する。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Git\\test\\blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. テーマを選定する https://themes.gohugo.io/にいい感じのテーマが沢山あるので好きなものを選びます。（ここでは仮に、Hugo Future Imperfect Slimを選択したとする）Download ボタンを押すと、GitHub のリポジトリトップに遷移するので、README を読みながら設定を進めます。\nテーマのインストール テーマは Git の Submodule として管理するのが主流みたいです。\n$ cd blog/themes $ git submodule add https://github.com/pacollins/hugo-future-imperfect-slim.git $ git submodule update --remote --merge 設定ファイルをコピーし修正する サンプルサイトの設定ファイル（config.toml, staticman.yml）を自サイトのルートにコピーします。\n$ cp ./hugo-future-imperfect-slim/exampleSite/config.toml ../ $ cp ./hugo-future-imperfect-slim/exampleSite/staticman.yml ../ この手の設定は、自分で動かしながら変えていくのが手っ取り早いかなと思いました。（分からない所だけドキュメントを参照する）\nGitHub Pages で公開する .github/workflows/gh-pages.ymlを作成する。詳細な説明は、リポジトリを参照してください。\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.74.2\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 後は、master に push すればhttps://\u0026lt;github username\u0026gt;.github.io/\u0026lt;repository name\u0026gt;として公開されます！\n終わりに 細かい個所などは紹介できていないので、詳細が気になる方はリポジトリを参照してください。\n参考  https://gohugo.io/ https://github.com/peaceiris/actions-hugo https://github.com/shukawam/blog  ","ref":"/blog/2020/0909-about-this-blog/"}]