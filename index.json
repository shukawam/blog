[{"title":"Oracle FunctionsのCold Start対策","date":"","description":"","body":"始めに OCI の FaaS サービスである Functions の Cold Start の対策をメモしておく。将来的に事前暖機の機能等がリリースされた場合、本記事はアンチパターンとなる可能性があることをご了承の上参照してください。(あくまで、2021/04/08 現在取りえる手法として書きます)\nFunctions の定期実行 この手のサービスではよくとられてきた手法ですが、Functions に適当なエンドポイントを用意して定期的に実行するというものです。コンテナが落ちるまでの具体的な時間は不明ですが、感覚的に 15 ~ 20 分といった所なので 10 分に一回叩けば問題ないと思います。現在、Functions 自体に定期実行するような機能は存在しないので外部から実行してあげる必要がありますが、具体的に取りえる方法としては以下の通り。(他にもあるかもしれないですが\u0026hellip;)\n 適当な Compute Instance から CLI や SDK、署名付きの HTTP エンドポイントを定期的に叩く OCI Monitoring の Health Check を使用する  一つずつ簡単に紹介します。\n適当な Compute Instance から定期実行する こちらは、特に解説不要かな、、cron でも書いて適当に叩いてください。\nOCI Monitoring の Health Check 機能を使用する Health Check のエンドポイントを持つ Functions を作成する fn init --runtime java11 fn-hello 一つの Functions に対して、API Gateway でエンドポイントを複数作成し、そのパスで分岐処理するパターンです。\n今回は、\n /cold/hello: Hello, world という文字列を返却するエンドポイント /cold/health: 定期実行用の常に{\u0026quot;status\u0026quot;: \u0026quot;UP\u0026quot;}を返却するエンドポイント  といった形で作ってみました。\npackage com.example.fn; import com.fnproject.fn.api.httpgateway.HTTPGatewayContext; public class HelloFunction { private static final String HEALTH_CHECK_URL = \u0026#34;/cold/health\u0026#34;; public static class HealthCheckResult { public HealthStatus status; public HealthCheckResult() { // default constructor.  } public HealthCheckResult(HealthStatus status) { this.status = status; } } public enum HealthStatus { UP, DOWN } public Object handleRequest(HTTPGatewayContext httpGatewayContext) { return HEALTH_CHECK_URL.equals(httpGatewayContext.getRequestURL()) ? healthCheck() : hello(); } private String hello() { return \u0026#34;Hello, world!!\u0026#34;; } private HealthCheckResult healthCheck() { // always return \u0026#34;UP\u0026#34;  return new HealthCheckResult(HealthStatus.UP); } } 作った Functions をデプロイします。\nfn --verbose deploy --app \u0026lt;your-app-name\u0026gt; API Gateway こちらは、同一 Functions に対し、以下のようにルーティングを二つ設定します。\n ルーティング 1  パス: /hello メソッド: GET タイプ: Oracle Functions アプリケーション、機能名: 自分で作成したアプリケーションの名前と関数名を指定する   ルーティング 2  パス: /health メソッド: GET タイプ: Oracle Functions アプリケーション、機能名: ルーティング 1 で指定したものと同じアプリケーション、関数名を指定する    Monitoring の設定 こちらは、OCI Monitoring の持つ Health Check 機能を使用して、API Gateway 経由で公開されている Functions のエンドポイントを定期的に実行するというものです。\nOCI コンソールから モニタリング \u0026gt; ヘルス・チェックと選択する。\nヘルス・チェックの作成を押します。\n以下のように入力し、ヘルス・チェックを作成します。\n ヘルス・チェック名: functions-health-check ターゲット: API Gateway のホスト名 バンテージ・ポイント: AWS Central EU1, Azure North Europe, Google West US プロトコル: HTTPS ポート: 443 パス: /cold/health(API Gateway に設定した Functions の Health Check 用のエンドポイント) メソッド: GET タイムアウト: 30 秒 間隔: 10 分  ヘルス・チェックの履歴を見た際に可用性が使用可能となっていれば OK です。\n終わりに いかがでしたでしょうか。今回紹介した Functions 内に複数機能を持つような設計は複数機能での Cold Start を避けるという意味では非常に理にかなった設計となります。だからと言って、全ての機能を単一の関数内に閉じ込めると今度は、コンテナイメージが大きくなりすぎてしまい、イメージのプルに時間がかかってしまうなどの問題もあるのでバランスを見ながら設計していく必要があります。\n参考  Using OCI Monitoring Healthchecks to Schedule execution of Serverless Functions on Oracle Cloud Infrastructure  ","ref":"/blog/blog/2021/0408-oracle-functions-cold-start/"},{"title":"FIDO2 Tips & Considering","date":"","description":"","body":"始めに FIDO2 をアプリケーションに組み込むときのちょっとした Tips や考慮しないといけないことを思いつくままにまとめてみようと思います。思いつく＆何か新しい発見があるたびに記事は随時更新していきます。\nTips Virtual Authenticators Tab まずは、Chrome の拡張機能の紹介です。組織のポリシーなどで会社支給のパソコンからinternalの認証器が呼び出せないパターンもあるでしょう。例えば、デモやちょっとした検証をやりたいのにわざわざそのために USB セキュリティキーを買うのもちょっと馬鹿らしいですよね。そんな時に非常に役に立ちます。\n使い方自体は非常に簡単で、まずは chrome ウェブストア - Virtual Authenticators Tabで当該機能を有効化する。\nVirtual Authenticators Tab を追加しますか？ というポップアップが出てくるので、拡張機能を追加 を押して追加する。\n確認には、おなじみのwebauthn.ioが良いと思います。\nまずは、DevTool を開き追加されているVirtual Authenticators内にあるEnable Virtual Authenticator Environmentのチェックボックスにチェックを入れます。\n後は、お好きな仮想認証器を生成してください。一応、設定できるパラメータを解説すると\n Protocol  ctap2  CTAP1 を FIDO2 用に拡張したもの   u2f  CTAP1 のことでクライアントと外部認証器との通信プロトコルのこと 選択肢では、internalが選択できそうですが、作成の際にエラーメッセージが出力されます     Transport  usb  USB セキュリティキーのこと(e.g. Yubikey)   nfc  Near Field Communication(e.g. Suica, Pasmo)   ble  Bluetooth Smart/Bluetooth Low Energy Technology   internal  プラットフォームの認証器のこと(e.g. Windows Hello, Apple Touch ID, iPhone Face ID)     Supports Resident Keys  認証器内の保存領域にサービスの情報＆ユーザーの情報の保存をサポートするかどうか CTAP2 から追加された仕様でユーザビリティ向上のための仕様   Supports User Verification  認証器の持つ本人確認機能を有効にするかどうか    Considering ユーザーの負担 Web 標準の認証規格となった WebAuthn だが、どれだけ認証時の利便性が高くなろうとも結局ユーザーが認証器(で生成される公開鍵)をサービス(Relying Party)に登録しなければならない事には変わりはない。現在自分が管理しているパスワードの数がどれだけになるかは分からない(おそらく 100 以上)が、その全てのワークフローにおいてパスワードから認証器に置き換えていく運用が行われていくことはあまり想像できない。従って、一般的には OIDC(OpenId Connect)等と組み合わせた ID 連携の仕組みを補完的に使用することが重要である。\nまとめると、以下のようになる。(全て個人の意見なので参考にする際はよく検討してください)\n 別のシステムとの連携などは一切考える必要がなくそれ一つで完結するシステム  Relying Party の実装方法  OSS のライブラリを使用して実装する FIDO2 の Relying Party を実装している Identity Provider を使用する(おすすめはこっち)     別のシステムと連携が必要なシステム  Relying Party の実装方法  FIDO2 の Relying Party を実装している Identity Provider を使用する      ID 連携の必要の有無で選択肢が微妙に変わります。必要ないのであれば、極端なことを言えば好きに作ればよいと思いますし、連携する可能性があるのであれば、素直に IdP を使った方がよいと思います。ただし、IdP を採用する場合は、Relying Party の実装が良くも悪くも完全に IdP に依存してしまうというのは少し考慮が必要な点かもしれません。\n","ref":"/blog/blog/2021/0406-webauthn-tips/"},{"title":"WebAuthn DeepDive #2 - Attestation","date":"","description":"","body":"始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。\nAbout Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。\nDeep Dive まずは、原文を読んでみましょう。\n Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision. However, if an attestation key pair is not available, then the authenticator MUST perform self attestation of the credential public key with the corresponding credential private key. All this information is returned by authenticators any time a new public key credential is generated, in the overall form of an attestation object. The relationship of the attestation object with authenticator data (containing attested credential data) and the attestation statement is illustrated in figure 5, below.\n 雑に訳すと、\n Authenticator(認証器)は、何らかの認証を提供する必要がある(生成した公開鍵の出所を証明すること) Authenticator(認証器)の満たすべき基本的な要件は以下  クレデンシャル公開鍵(登録時に生成される公開鍵)について、WebAuthn RP が検証可能な証明書(attestation statement)を作成できる事 attestation statementには以下の情報を含む(RP はこれらの情報を用いて、公開鍵の出所の妥当性を検証を行う)  FIDO2 認証ベンダーから認証器内のセキュア領域に埋め込まれた秘密鍵によって生成された署名 RP から発行された challenge 公開鍵の出所情報を提供する証明書(もしくはそれに値する情報)      となる。何となく、FIDO2 における Attestation がどういうものだか分かってきたので、WebAuthn 実行後に認証器から返却されるデータを振り返ってみましょう。こんなデータが返ってきます。\n{ \u0026#34;id\u0026#34;: \u0026#34;xTzphZPuJyfW12TAT…\u0026#34;, \u0026#34;rawId\u0026#34;: ArrayBuffer(64) {}, \u0026#34;response\u0026#34;: { \u0026#34;attestationObject\u0026#34;: ArrayBuffer(1024), \u0026#34;clientDataJSON\u0026#34;: ArrayBuffer(116) {} }, \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34; } 今回ちゃんと仕様を読んでいくのは、このうちattestationObjectということになります。\nAttestation Object attestationObjectは、CBOR1で表現されており、W3C で仕様が公開されています。具体的には以下の通り。\nもう少し、開発者に分かりやすく JSON 形式で表現すると以下のようになる。\n[ { \u0026#34;fmt\u0026#34;: \u0026#34;packed\u0026#34;, \u0026#34;attStmt\u0026#34;: { \u0026#34;alg\u0026#34;: -7, \u0026#34;sig\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Buffer\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;...\u0026#34; }, \u0026#34;x5c\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;Buffer\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;...\u0026#34; } ] }, \u0026#34;authData\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Buffer\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;...\u0026#34; } } ] 各プロパティ内に含まれるバイナリデータまで見ていきましょう。\nfmt Defined Attestation Statement Formatsによると、以下の種類があるそうです。\n   Format Attestation Support Type 説明     Packed Basic, Self, AttCA WebAuthn に最適化されたフォーマット   TPM AttCA Trusted Platform Module を暗号エンジンとして使用する認証器で使用される   Android Key Basic 対象となる認証器が Android N(Nougat) 移行のプラットフォーム認証器の場合に使用される   Android SafetyNet Basic 認証器が特定の Android プラットフォーム上の認証器の場合、SafetyNet API に基づいても良い   FIDO U2F Basic, AttCA FIDO U2F 認証器で使用される   None None Relying Party が認証情報を受け取ることを希望しない場合に使用する   Apple Anonymous Anonymization CA Apple が WebAuthn をサポートする特定の種類の Apple デバイスに対して独占的に使用される    上の Attestation Object の構造の所で先出ししてしまいましたが、今回はPackedの場合のみ取り扱います。\nAttedted Credential Data 下図の赤枠でかこっている箇所の話です。\nauthData内に含まれる Attested Credential Data は、以下のような構成になっています。\n   プロパティ名 バイト長 説明     aaguid 16 認証器のタイプを示す 128bit(16byte)の識別子のこと   credentialIdLength 2 クレデンシャル ID のバイト長を示す 16bit(2byte)の符号なしビッグエンディアン整数   credentialId L クレデンシャルを一意に識別する ID   credentialPublicKey variable COSE_Key 形式でエンコードされたクレデンシャル公開鍵(認証器で生成された公開鍵)    ここに COSE_Key 形式でエンコードされた以降の認証フローで使用するための公開鍵が含まれているので、検証終了時に Database で永続化しておきます。\nattStmt 下図の赤枠でかこっている箇所の話です。\n何やら、FIDO2 認証ベンダーの秘密鍵によって生成された署名や証明書が含まれていそうです。きちんとプロパティを見ていくと、以下のようになっています。(今回は Basic の場合)\n   プロパティ名 説明     alg COSE Algorithm Identifier で指定する sig(署名)の暗号化アルゴリズム   sig FIDO 認証ベンダー固有の秘密鍵によって生成された署名   x5c attestnCert (とその証明書チェーン)が含まれていて、それぞれ X.509 形式でエンコードされている    署名の検証手順については、6.5.2. Attestation Statement Formatsに記されています。(OSS のライブラリの開発などやフルスクラッチで実装しようという方以外は知らなくても大丈夫な部分かと思われます)\n参考  W3C WebAuthn    Concise Binary Object Representation (CBOR)の略で、バイナリの JSON のようなもの \u0026#x21a9;\u0026#xfe0e;\n   ","ref":"/blog/blog/2021/0404-webauthn-deep-dive/"},{"title":"WebAuthn DeepDive #1 - navigator.credentials.create()","date":"","description":"","body":"始めに WebAuthn について学習したときのメモ。今回は、WebAuthnよりも CTAP の話が多めかも。\nDeep Dive この辺の仕様を読んでいく。\n※図はhttps://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_APIから参照\n全体の流れとしては、\nnavigator.credentials.create()が実行される  authenticatorMakeCredential()を実行するためのパラメータを組み立てる   認証器のauthenticatorMakeCredential()が呼び出される authenticatorMakeCredential()を実行した結果がブラウザに返される  となっています。WebAuthn が実行され、認証器のauthenticatorMakeCredential()が呼び出される所から順番に見ていきます。\n2. navigator.credentials.create()の実行 navigator.credentials.create()が呼び出されると、認証器のauthenticatorMakeCredential()を実行するためのパラメータを組み立てて実行します。その際、authenticatorMakeCredential()実行のために必要なパラメータの仕様は、こちらに公開されています。一部抜粋して読んでいきたいと思います。(ひとまず今回は、Required のものだけ確認していきます)\n   パラメータ名 型 概要     clientDataHash Byte Array clientData のハッシュ   rp PublicKeyCredentialRpEntity Relying Party の情報   user PublicKeyCredentialUserEntity 新しく生成する Credential に紐づくユーザーの情報   pubKeyCredParams CBOR Array 生成する Credential のパラメータ(type: public-keyで固定, alg: 公開鍵の暗号化アルゴリズム)    clientDataHash  Hash of the ClientData contextual binding specified by host. See [WebAuthN].\n clientData のハッシュ\u0026hellip;これだけ言われても、正直意味が分からないですが、WebAuthNを見ろとの事なので見てみます。\n This attribute, inherited from AuthenticatorResponse, contains the JSON-compatible serialization of client data (see § 6.5 Attestation) passed to the authenticator by the client in order to generate this credential. The exact JSON serialization MUST be preserved, as the hash of the serialized client data has been computed over it.\n Credential(パスワードや生体情報などユーザ認証に必要な情報)を生成するのに必要なクライアントデータが JSON 互換のシリアライズされたものだそう。JSON-compatible serialization of client dataをもう少し見てみましょう。\n JSON-compatible serialization of client data This is the result of performing the JSON-compatible serialization algorithm on the CollectedClientData dictionary.\n CollectedClientDataがシリアライズされたものだという事が分かりました。CollectedClientData は以下のようになっています。\ndictionary CollectedClientData { required DOMString type; required DOMString challenge; required DOMString origin; boolean crossOrigin; TokenBinding tokenBinding; }; dictionary TokenBinding { required DOMString status; DOMString id; }; enum TokenBindingStatus { \u0026#34;present\u0026#34;, \u0026#34;supported\u0026#34; }; ここでも Required のプロパティのみ見ていきます。\n   パラメータ名 型 概要     type DOMString Credential を生成するときはwebauthn.create、取得するときにはwebauthn.getが固定値で設定される   challenge DOMString Relying Party で生成された challenge(16 バイト以上のランダムバッファー)が base64url エンコードされたものが設定される   origin DOMString クライアントの origin(e.g. http://localhost:4200)が設定される    ということで、authenticatorMakeCredential()が実行されるときには以下のようなデータがシリアライズされて渡されるみたいです。\n{ \u0026#34;type\u0026#34;: \u0026#34;webauthn.create\u0026#34;, \u0026#34;challenge\u0026#34;: \u0026#34;xTzphZPuJyfW12TAT…\u0026#34;, \u0026#34;origin\u0026#34;: \u0026#34;https://example.com\u0026#34; } ちなみに、シリアライズするときの手順はこちら(5.8.1.1. Serialization)に記されております。\nrp  This PublicKeyCredentialRpEntity data structure describes a Relying Party with which the new public key credential will be associated. It contains the Relying party identifier, (optionally) a human-friendly RP name, and (optionally) a URL referencing a RP icon image. The RP name is to be used by the authenticator when displaying the credential to the user for selection and usage authorization.\n とのことで、Relying Party の情報が含まれているデータのようです。最終的には、以下のようなデータが渡されます。\n{ // Required \u0026#34;id\u0026#34;: \u0026#34;example.com\u0026#34;, // Relying Partyを識別するID // Optionally \u0026#34;name\u0026#34;: \u0026#34;Relying Party Example\u0026#34;, // Relying Partyの名前 \u0026#34;icon\u0026#34;: \u0026#34;https://example.com/...\u0026#34; // アイコンイメージが格納されている場所をURLで指定する } navigator.credentials.create()の実行時に渡したパラメータがそのまま渡されるようです。\nuser  This PublicKeyCredentialUserEntity data structure describes the user account to which the new public key credential will be associated at the RP. It contains an RP-specific user account identifier, (optionally) a user name, (optionally) a user display name, and (optionally) a URL referencing a user icon image (of a user avatar, for example). The authenticator associates the created public key credential with the account identifier, and MAY also associate any or all of the user name, user display name, and image data (pointed to by the URL, if any).\n とのことで、新しい公開鍵 Credential が紐づけられるユーザーの情報が含まれます。最終的には、以下のようなデータが渡されます。\n{ // Required \u0026#34;id\u0026#34;: BufferSource, // ユーザーを一意に識別するID // Optionally \u0026#34;displayName\u0026#34;: \u0026#34;John P. Smith\u0026#34;, // 表示名 \u0026#34;name\u0026#34;: \u0026#34;john.p.smith@example.com\u0026#34; // ユーザー名 } navigator.credentials.create()の実行時に渡したパラメータがそのまま渡されるようです。\npubKeyCredParams  A sequence of CBOR maps consisting of pairs of PublicKeyCredentialType (a string) and cryptographic algorithm (a positive or negative integer), where algorithm identifiers are values that SHOULD be registered in the IANA COSE Algorithms registry [IANA-COSE-ALGS-REG]. This sequence is ordered from most preferred (by the RP) to least preferred.\n Credential のタイプと署名のアルゴリズムを指定する項目となっています。最終的には、以下のようなデータが渡されます。\n[ { \u0026#34;alg\u0026#34;: -7, \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34; } //... ] navigator.credentials.create()の実行時に渡したパラメータがそのまま渡されるようです。\n4. authenticatorMakeCredential()を実行した結果 authenticatorMakeCredential()を実行すると以下のようなデータがブラウザ(JavaScript Application)に返却されます。\n{ \u0026#34;id\u0026#34;: \u0026#34;xTzphZPuJyfW12TAT…\u0026#34;, \u0026#34;rawId\u0026#34;: ArrayBuffer(64) {}, \u0026#34;response\u0026#34;: { \u0026#34;attestationObject\u0026#34;: ArrayBuffer(1024), \u0026#34;clientDataJSON\u0026#34;: ArrayBuffer(116) {} }, \u0026#34;type\u0026#34;: \u0026#34;public-key\u0026#34; } それぞれのプロパティを見ていきましょう。\n   パラメータ名 概要     id rawId を base64url エンコードしたもの   rawId Credential 毎に一意に定められている   attestationObject 認証用の公開鍵や CredentialID、署名などが含まれている   clientDataJSON challenge, oritin, type などが含まれている clientData を JSON シリアライズしたもの(ref: clientDataHash)   type public-key固定    このうち、attestationObject, clientDataJSONを Relying Party へ送信し検証が成功すれば登録処理は完了です。\n参考  Web Authentication API Client to Authenticator Protocol (CTAP)  ","ref":"/blog/blog/2021/0324-webauthn-deep-dive/"},{"title":"Spring Native Getting Started","date":"","description":"","body":"始めに Spring Nativeを使って、Spring Boot アプリケーションを Native Image 化してみます。\n手順 Spring Initializr を使用してひな形を作成します。今回は、Helath Check のエンドポイントを一つ有するアプリケーションを作成します。\ncurl -G https://start.spring.io/starter.zip -o spring-boot-native-image-sample.zip -d javaVersion=11 -d dependencies=web,actuator,native % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 57164 100 57164 0 0 106k 0 --:--:-- --:--:-- --:--:-- 106k 解凍します。\nunzip spring-boot-native-image-sample.zip -d spring-boot-native-image Archive: spring-boot-native-image-sample.zip inflating: spring-boot-native-image/.gitignore inflating: spring-boot-native-image/HELP.md inflating: spring-boot-native-image/mvnw creating: spring-boot-native-image/src/ creating: spring-boot-native-image/src/main/ creating: spring-boot-native-image/src/main/java/ creating: spring-boot-native-image/src/main/java/com/ creating: spring-boot-native-image/src/main/java/com/example/ creating: spring-boot-native-image/src/main/java/com/example/demo/ inflating: spring-boot-native-image/src/main/java/com/example/demo/DemoApplication.java creating: spring-boot-native-image/src/main/resources/ creating: spring-boot-native-image/src/main/resources/templates/ creating: spring-boot-native-image/src/main/resources/static/ inflating: spring-boot-native-image/src/main/resources/application.properties creating: spring-boot-native-image/src/test/ creating: spring-boot-native-image/src/test/java/ creating: spring-boot-native-image/src/test/java/com/ creating: spring-boot-native-image/src/test/java/com/example/ creating: spring-boot-native-image/src/test/java/com/example/demo/ inflating: spring-boot-native-image/src/test/java/com/example/demo/DemoApplicationTests.java creating: spring-boot-native-image/.mvn/ creating: spring-boot-native-image/.mvn/wrapper/ inflating: spring-boot-native-image/.mvn/wrapper/maven-wrapper.jar inflating: spring-boot-native-image/.mvn/wrapper/MavenWrapperDownloader.java inflating: spring-boot-native-image/.mvn/wrapper/maven-wrapper.properties inflating: spring-boot-native-image/pom.xml inflating: spring-boot-native-image/mvnw.cmd Native Image を生成します。\ncd spring-boot-native-image/ mvn spring-boot:build-image しばらく待つと、Docker Image が生成される。\ndocker images | grep demo demo 0.0.1-SNAPSHOT 4c417a6969fa 41 years ago 90MB ちなみに、CREATED が 41 years ago になるのは仕様らしいです。(ちょっと気持ち悪い)\nref: https://stackoverflow.com/questions/62865594/spring-boot-2-3-0-buildpack-builds-image-with-creation-date-40-years-ago\n This is expected. In order to create reproducible builds (i.e. so that layers can be reused) the buildpack must create layers with a fixed time stamp. Otherwise, you wouldn’t be able to reuse the layers you created in previous builds because they would have different time stamps.\n また、比較のために Fat JAR の Docker Image も生成しておきます。\ndocker build -t shukawam/spring-boot-fat-jar:v1.0 -f Dockerfile ./ docker images | grep shukawam/spring-boot-fat-jar shukawam/spring-boot-fat-jar v1.0 ccf63974666c 31 seconds ago 239MB 両方とも起動の時間を確認してみます。まずは、Fat JAR から。\ndocker run --rm -p 8080:8080 shukawam/spring-boot-fat-jar:v1.0 2021-03-23 09:46:02.644 INFO 1 --- [ main] o.s.nativex.NativeListener : This application is bootstrapped with code generated with Spring AOT . ____ _ __ _ _ /\\\\ / ___\u0026#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | \u0026#39;_ | \u0026#39;_| | \u0026#39;_ \\/ _` | \\ \\ \\ \\  \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) \u0026#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.4) 2021-03-23 09:46:02.737 INFO 1 --- [ main] com.example.demo.DemoApplication : Starting DemoApplication v0.0.1-SNAPSHOT using Java 11.0.10 on 2e42d385fb33 with PID 1 (/spring-boot/demo-0.0.1-SNAPSHOT.jar started by root in /spring-boot) 2021-03-23 09:46:02.738 INFO 1 --- [ main] com.example.demo.DemoApplication : No active profile set, falling back to default profiles: default 2021-03-23 09:46:03.933 INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) 2021-03-23 09:46:03.945 INFO 1 --- [ main] o.apache.catalina.core.StandardService : Starting service [Tomcat] 2021-03-23 09:46:03.945 INFO 1 --- [ main] org.apache.catalina.core.StandardEngine : Starting Servlet engine: [Apache Tomcat/9.0.44] 2021-03-23 09:46:04.002 INFO 1 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring embedded WebApplicationContext 2021-03-23 09:46:04.002 INFO 1 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 1204 ms 2021-03-23 09:46:04.578 INFO 1 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-03-23 09:46:04.819 INFO 1 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; 2021-03-23 09:46:04.865 INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path \u0026#39;\u0026#39; 2021-03-23 09:46:04.879 INFO 1 --- [ main] com.example.demo.DemoApplication : Started DemoApplication in 2.605 seconds (JVM running for 3.05) 2021-03-23 09:46:10.908 INFO 1 --- [nio-8080-exec-1] o.a.c.c.C.[Tomcat].[localhost].[/] : Initializing Spring DispatcherServlet \u0026#39;dispatcherServlet\u0026#39; 2021-03-23 09:46:10.909 INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet \u0026#39;dispatcherServlet\u0026#39; 2021-03-23 09:46:10.910 INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 1 ms JVM が起動してから大体 2.6 秒です。お次に、Native Image 版。\ndocker run -p 8080:8080 docker.io/library/demo:0.0.1-SNAPSHOT 2021-03-23 09:47:57.657 INFO 1 --- [ main] o.s.nativex.NativeListener : This application is bootstrapped with code generated with Spring AOT . ____ _ __ _ _ /\\\\ / ___\u0026#39;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\ ( ( )\\___ | \u0026#39;_ | \u0026#39;_| | \u0026#39;_ \\/ _` | \\ \\ \\ \\  \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) \u0026#39; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.4.4) 2021-03-23 09:47:57.658 INFO 1 --- [ main] com.example.demo.DemoApplication : Starting DemoApplication using Java 11.0.10 on 26edf77d8c85 with PID 1 (/workspace/com.example.demo.DemoApplication started by cnb in /workspace) 2021-03-23 09:47:57.658 INFO 1 --- [ main] com.example.demo.DemoApplication : No active profile set, falling back to default profiles: default 2021-03-23 09:47:57.697 INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat initialized with port(s): 8080 (http) Mar 23, 2021 9:47:57 AM org.apache.coyote.AbstractProtocol init INFO: Initializing ProtocolHandler [\u0026#34;http-nio-8080\u0026#34;] Mar 23, 2021 9:47:57 AM org.apache.catalina.core.StandardService startInternal INFO: Starting service [Tomcat] Mar 23, 2021 9:47:57 AM org.apache.catalina.core.StandardEngine startInternal INFO: Starting Servlet engine: [Apache Tomcat/9.0.44] Mar 23, 2021 9:47:57 AM org.apache.catalina.core.ApplicationContext log INFO: Initializing Spring embedded WebApplicationContext 2021-03-23 09:47:57.699 INFO 1 --- [ main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 41 ms 2021-03-23 09:47:57.701 WARN 1 --- [ main] i.m.c.i.binder.jvm.JvmGcMetrics : GC notifications will not be available because MemoryPoolMXBeans are not provided by the JVM 2021-03-23 09:47:57.714 INFO 1 --- [ main] o.s.s.concurrent.ThreadPoolTaskExecutor : Initializing ExecutorService \u0026#39;applicationTaskExecutor\u0026#39; 2021-03-23 09:47:57.726 INFO 1 --- [ main] o.s.b.a.e.web.EndpointLinksResolver : Exposing 2 endpoint(s) beneath base path \u0026#39;/actuator\u0026#39; Mar 23, 2021 9:47:57 AM org.apache.coyote.AbstractProtocol start INFO: Starting ProtocolHandler [\u0026#34;http-nio-8080\u0026#34;] 2021-03-23 09:47:57.728 INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path \u0026#39;\u0026#39; 2021-03-23 09:47:57.729 INFO 1 --- [ main] com.example.demo.DemoApplication : Started DemoApplication in 0.076 seconds (JVM running for 0.077) Mar 23, 2021 9:48:01 AM org.apache.catalina.core.ApplicationContext log INFO: Initializing Spring DispatcherServlet \u0026#39;dispatcherServlet\u0026#39; 2021-03-23 09:48:01.198 INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Initializing Servlet \u0026#39;dispatcherServlet\u0026#39; 2021-03-23 09:48:01.198 INFO 1 --- [nio-8080-exec-1] o.s.web.servlet.DispatcherServlet : Completed initialization in 0 ms ログには、Started DemoApplication in 0.076 seconds (JVM running for 0.077)と書いてありますが、内部では JVM の起動を介さずに直接 Machine Code が実行されているので、少し誤解を生んでしまうログ出力かもしれません。細かいことは置いておいて、起動に要した時間は大体 0.07 秒といった所です。Fat JAR に比べると 37 倍も速いですね。また、イメージの容量に関しても 1/2 以下となっています。\nおまけ Fat JAR 生成に使用した Dockerfile は以下\n# 1st stage, build the appFROMmaven:3.6-jdk-11 as buildWORKDIR/spring-boot# Create a first layer to cache the \u0026#34;Maven World\u0026#34; in the local repository.# Incremental docker builds will always resume after that, unless you update# the pomADD pom.xml .ADD src srcRUN mvn package# 2nd stage, build the runtime imageFROMopenjdk:11-jre-slimWORKDIR/spring-boot# Copy the binary built in the 1st stageCOPY --from=build /spring-boot/target/demo-0.0.1-SNAPSHOT.jar ./CMD [\u0026#34;java\u0026#34;, \u0026#34;-jar\u0026#34;, \u0026#34;demo-0.0.1-SNAPSHOT.jar\u0026#34;]EXPOSE8080終わりに FaaS 上で Spring アプリケーションが動く日もそんな遠い話じゃないかもなと感じました。(プラットフォームが GraalVM をサポートしていればの話ですが) ちなみに、サポートについてはSpring Native - 3. Supportを参照すると、どのコンポーネントが対応／非対応かが記されています。\n参考  Spring Native documentation  ","ref":"/blog/blog/2021/0322-spring-boot-native-image/"},{"title":"Helidon SE Component - Config, OpenAPI","date":"","description":"","body":"始めに Java の軽量フレームワークの一つであるHelidonの全コンポーネントを触っていくエントリーの一回目です。本日は、\n Config OpenAPI  について触っていこうと思います。\nComponents Config  様々なソース(.properties, .yaml, .json)から Config オブジェクトに設定プロパティをロードして処理するための Java API を提供します 各種設定情報をソースコードから分離することでコード自体の保守性を向上させたりする目的があります  早速、試していきます。CLI を使用してひな形を生成した場合は、自動的に Config 関連の依存関係が含まれていますが、含まれていない場合は以下をpom.xmlに追加します。\npom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.config\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-config-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 今回は、yaml形式で記載したいと思います。jsonでもpropertiesでも結果は同じですが個人的にyamlが好きだからです。（一番無駄がないし、視認性もよい）\nresources/application.yamlに Config オブジェクトにマッピングさせる情報を記載していきます。\napplication.yaml\napp: greeting: \u0026#34;Hello\u0026#34; config: \u0026#34;config service works!!\u0026#34; # 追記 server: port: 8080 host: 0.0.0.0 application.yamlに記載した項目を参照するには以下のようにします。\nvar config = Config.create(); var value = config.get(\u0026#34;app.config\u0026#34;).asString().orElse(\u0026#34;config service NOT work\u0026#34;); OpenAPI  OpenAPI 仕様のドキュメントを生成するエンドポイントを容易に生成することができる Eclipse MicroProfile の OpenAPI 仕様となっているので、実装などで困った際は Helidon のドキュメントではなく、MicroProfile の OpenAPI 仕様のドキュメントを参考にするとよい  早速、試していきます。まずは、OpenAPI 関連の依存関係をpom.xmlに追加します。\npom.xml\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.openapi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-openapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OpenAPISupportをサーバの設定に追加します。\nreturn Routing.builder() // ...  // OpenAPI support  .register(OpenAPISupport.create(config)) .build(); OpenAPI ドキュメントを構築するためにいくつか手段があります。\n  OpenAPI の定義ファイルを作成する\n META-INF/openapi.yml, META-INF/openapi.yaml, META-INF/openapi.json に定義を追加する    org.eclipse.microprofile.openapi.OASModelReaderインタフェースを実装した Java クラスに定義を記述する\n  1. OpenAPI の定義ファイルを作成する 今回は、以下のようなサンプルファイルを生成しました。\nopenapi.yaml\nopenapi: 3.0.0 info: title: Helidon SE OpenAPI Example. description: helidon se openapi example. version: 1.0.0 servers: - url: http://localhost:8080 description: Local server. components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string paths: /greet: get: summary: Returns a generic greeting description: Greets the user generically responses: \u0026#34;200\u0026#34;: description: OK content: application/json: examples: Greet: value: message: Hello World! /config: get: summary: Returns a config properties. description: return a config properties. responses: \u0026#34;200\u0026#34;: description: OK content: application/json: examples: Config: value: message: config service works!! API 仕様のエンドポイントは/openapiとなっているため、特にヘッダー情報を追加せずにリクエストを送るとYAML形式のデータ(上記の定義ファイルと同じ内容)を返却します。\nservers: - description: Local server. url: http://localhost:8080 components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string info: description: helidon se openapi example. title: Helidon SE OpenAPI Example. version: 1.0.0 openapi: 3.0.0 paths: /greet: get: description: Greets the user generically responses: \u0026#34;200\u0026#34;: content: application/json: examples: Greet: value: message: Hello World! description: OK summary: Returns a generic greeting /config: get: description: return a config properties. responses: \u0026#34;200\u0026#34;: content: application/json: examples: Config: value: message: config service works!! description: OK summary: Returns a config properties. ちなみに、ドキュメントを取得するパスを変更したい場合は以下のように設定を変更します。\napplication.yaml\nopenapi: web-context: /myopenapi # 任意のパスに変更可能 2. org.eclipse.microprofile.openapi.OASModelReaderインタフェースを実装した Java クラスに定義を記述する まずは、設定ファイルにOASModelReaderを使用することを記述します。具体的には以下のように。\napplication.yaml\n# OpenAPI configuration. openapi: model: reader: shukawam.examples.helidon.se.openapi.OpenAPIModelReader さて、実装クラスですが今回は以下のように実装してみました。\npublic class OpenAPIModelReader implements OASModelReader { // OASModelReaderの実装クラスを作成する  private static final String MODEL_READER_PATH = \u0026#34;/openapi/test\u0026#34;; private static final String DESCRIPTION = \u0026#34;A sample endpoint from OASModelReader.\u0026#34;; @Override public OpenAPI buildModel() { PathItem pathItem = OASFactory.createPathItem() .GET(OASFactory.createOperation() .operationId(\u0026#34;test\u0026#34;) .description(DESCRIPTION) ); OpenAPI openAPI = OASFactory.createOpenAPI(); Paths paths = OASFactory.createPaths() .addPathItem(MODEL_READER_PATH, pathItem); openAPI.paths(paths); return openAPI; } } そのうえで先ほどのエンドポイントに対してリクエストを送ってみると、\nservers: - description: Local server. url: http://localhost:8080 components: schemas: GreetingMessage: properties: message: type: string ConfigMessage: properties: message: type: string info: description: helidon se openapi example. title: Helidon SE OpenAPI Example. version: 1.0.0 openapi: 3.0.0 paths: /openapi/test: # OASModelReaderの実装クラスで追加した情報が返却される get: description: A sample endpoint from OASModelReader. operationId: test /greet: get: description: Greets the user generically responses: \u0026#34;200\u0026#34;: content: application/json: examples: Greet: value: message: Hello World! description: OK summary: Returns a generic greeting /config: get: description: return a config properties. responses: \u0026#34;200\u0026#34;: content: application/json: examples: Config: value: message: config service works!! description: OK summary: Returns a config properties. これに加え、OASFilterを実装したクラスを作成し、適切な処理を実装すれば OpenAPI が内部モデルを構築する前に任意の処理を挟みこむことができます。\n終わりに 今回は、Config, OpenAPI のコンポーネントについて色々試してみました。次回は、DB Clientでも試してみようかと思います。\n参考   Helidon SE Component - Config\n  Helidon SE Component - OpenAPI\n  ","ref":"/blog/blog/2021/0212-helidon-se-components/"},{"title":"Helidon SE Get Started","date":"","description":"","body":"始めに Java の軽量フレームワークの一つである Helidon を何回かに分けて全コンポーネントを触ってみたいと思います。尚、Helidon には\n Helidon SE: 軽量でフットプリント重視 Helidon MP: Eclipse MicroProfile との互換性や機能性を重視  と、エディションが二つ存在しますが、一旦は SE の方に注目して触っていきたいと思います。(SE のコンポーネントを一通り試し終わったら、MP も同様に試していきます。) 今回は、アプリケーションの生成までをやっていきます。\n環境 一応、私の環境情報を載せておきます。\n OS: Windows 10(WSL2 で Ubuntu 18.04 を使用しています) Java: OpenJDK 11  手順 Helidon CLI を使う アプリケーションのひな型生成や開発モード（ソースコードの変更を再度ビルドする必要なく即時反映してくれる仕組み）をサポートしている便利ツールです。2021/02/06 現在、Windows はまだ CLI の配布がされていないため、ローカルで CLI を使用したい場合は、WSL2 で Ubuntu を使うなどのひと工夫が必要です。\nインストール自体は、非常に簡単でバイナリをダウンロードしてパスが通っているところにインストールするだけで大丈夫です。\n$ curl -O https://helidon.io/cli/latest/linux/helidon $ chmod +x ./helidon $ sudo mv ./helidon /usr/local/bin/ とりあえず、どんなことができるかを見ておきます。\n$ helidon --help Usage: helidon [OPTIONS] COMMAND Helidon Project command line tool Options: -D\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; Define a system property --verbose Produce verbose output --debug Produce debug output --plain Do not use color or styles in output Commands: build Build the application dev Continuous application development info Print project information init Generate a new project version Print version information Run \u0026#39;helidon COMMAND --help\u0026#39; for more information on a command. 細かいオプションを抜きにして以下の様な操作が可能となっています。\n build  アプリケーションのビルドができる --mode=PLAIN|NATIVE|JLINKで実行可能 JAR, Native Image(要 GraalVM), jlink を使用したビルドが選択可能   dev  Helidon のアプリケーションを開発モード(ソースコードの変更を即時反映してくれる仕組み)で起動することができる   info  プロジェクトの情報を出力できる   init  プロジェクトの生成ができる 対話形式 or オプションで指定することで用途に合わせたひな型からプロジェクトを生成することができる   version  バージョン情報を出力する    では、さっそくアプリケーションを作ってみたいと思います。まずは、ミニマルな構成で作成し、今後検証したコンポーネントを随時追加していきたいと思います。\n$ helidon init --flavor SE --build MAVEN --archetype bare --groupid shukawam.examples --package shukawam.examples.helidon.se --name helidon-se-examples Using Helidon version 2.2.0 Helidon flavor (1) SE (2) MP Enter selection (Default: 1): Select archetype (1) bare | Minimal Helidon SE project suitable to start from scratch (2) quickstart | Sample Helidon SE project that includes multiple REST operations (3) database | Helidon SE application that uses the dbclient API with an in-memory H2 database Enter selection (Default: 1): Project name (Default: helidon-se-examples): Project groupId (Default: shukawam.examples): Project artifactId (Default: helidon-se-examples): Project version (Default: 1.0-SNAPSHOT): Java package name (Default: shukawam.examples.helidon.se): Switch directory to /home/kawamura/git/helidon-se-examples to use CLI Start development loop? (Default: n): Helidon CLI で生成されたアプリケーションを少し見てみると、以下の様になっています。\n$ cd helidon-se-examples $ tree . ├── README.md ├── pom.xml └── src ├── main │ ├── java │ │ └── shukawam │ │ └── examples │ │ └── helidon │ │ └── se │ │ ├── GreetService.java # 自動生成されたサービスクラス(ビジネスロジックを記載するクラス) │ │ ├── Main.java # Mainクラス(サーバの起動やルーティングの設定を行うクラス) │ │ └── package-info.java │ └── resources │ ├── META-INF │ │ └── native-image │ │ └── reflect-config.json # Native Image 化する際の設定ファイル(Reflection API 関連の設定ファイルです。詳細は、https://www.graalvm.org/reference-manual/native-image/Reflection/をどうぞ) │ ├── application.yaml # Application の設定ファイル │ └── logging.properties # ログの設定ファイル └── test └── java └── shukawam └── examples └── helidon └── se └── MainTest.java # テストコード 16 directories, 9 files 開発モードで起動してみます。\n$ helidon dev helidon dev | source file changed | rebuilding (incremental) | rebuild completed (0.3 seconds) | helidon-se-examples starting 2021.02.06 23:10:47 INFO io.helidon.common.LogConfig Thread[main,5,main]: Logging at initialization configured using classpath: /logging.properties 2021.02.06 23:10:48 INFO io.helidon.common.HelidonFeatures Thread[features-thread,5,main]: Helidon SE 2.2.0 features: [Config, Health, Metrics, WebServer] 2021.02.06 23:10:48 INFO io.helidon.webserver.NettyWebServer Thread[nioEventLoopGroup-2-1,10,main]: Channel \u0026#39;@default\u0026#39; started: [id: 0x930f8a6a, L:/0:0:0:0:0:0:0:0:8080] WEB server is up! http://localhost:8080 in 1017 milliseconds (since JVM startup). JVM が起動してからアプリケーションが起動するまでの時間を計測したいので以下のログステートメントを追記しています。\nSystem.out.println( String.format( \u0026#34;WEB server is up! http://localhost:%s in %s milliseconds (since JVM startup).\u0026#34;, // 追記  ws.port(), ManagementFactory.getRuntimeMXBean().getUptime() ) ); 折角なので、Native Image も作ってみます。今回は GraalVM の環境を作らずに Native Image を作成するため、以下の様な Dockerfile を用意します。\nDockerfile.native\n# 1st stage, build the appFROMhelidon/jdk11-graalvm-maven:20.2.0 as buildWORKDIR/helidon# Create a first layer to cache the \u0026#34;Maven World\u0026#34; in the local repository.# Incremental docker builds will always resume after that, unless you update# the pomADD pom.xml .RUN mvn package -Pnative-image -Dnative.image.skip -DskipTests# Do the Maven build!# Incremental docker builds will resume here when you change sourcesADD src srcRUN mvn package -Pnative-image -Dnative.image.buildStatic -DskipTestsRUN echo \u0026#34;done!\u0026#34;# 2nd stage, build the runtime imageFROMscratchWORKDIR/helidon# Copy the binary built in the 1st stageCOPY --from=build /helidon/target/helidon-se-examples .ENTRYPOINT [\u0026#34;./helidon-se-examples\u0026#34;]EXPOSE8080Native Image を生成します。(手元の環境に GraalVM のランタイムが入っている場合は、Helidon build --mode NATIVEで Native Image のビルドができます。)\n$ docker build -t shukawam/helidon-se-native-image:v1.0 -f Dockerfile.native . 起動してみます。\n$ docker run -p 8080:8080 shukawam/helidon-se-native-image:v1.0 02021.02.06 15:13:23 INFO io.helidon.common.LogConfig Thread[main,5,main]: Logging at runtime configured using classpath: /logging.properties 2021.02.06 15:13:23 INFO io.helidon.common.HelidonFeatures Thread[features-thread,5,main]: Helidon SE 2.2.0 features: [Config, Health, Metrics, WebServer] 2021.02.06 15:13:23 INFO io.helidon.webserver.NettyWebServer Thread[nioEventLoopGroup-2-1,10,main]: Channel \u0026#39;@default\u0026#39; started: [id: 0x4c520a0c, L:/0.0.0.0:8080] WEB server is up! http://localhost:8080 in 18 milliseconds (since JVM startup). 18ms\u0026hellip;さすがに、起動は桁違いに速いです。\nちなみに、自動生成されたpom.xml内の依存関係は以下の様になっていました。\npom.xml\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.webserver\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-webserver\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.media\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-media-jsonp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.config\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-config-yaml\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.health\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-health\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.health\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-health-checks\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.metrics\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-metrics\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.junit.jupiter\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit-jupiter-api\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.helidon.webclient\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;helidon-webclient\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; マイクロサービスの実装に必要不可欠な Metrics, Health Check, Config といったライブラリは、既に含まれているので特に設定することなく、Metrics や Health Check のエンドポイントを利用可能になっています。\n# Health Check $ curl http://localhost:8080/health {\u0026#34;outcome\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;checks\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;deadlock\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;diskSpace\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;free\u0026#34;:\u0026#34;228.23 GB\u0026#34;,\u0026#34;freeBytes\u0026#34;:245060718592,\u0026#34;percentFree\u0026#34;:\u0026#34;90.93%\u0026#34;,\u0026#34;total\u0026#34;:\u0026#34;250.98 GB\u0026#34;,\u0026#34;totalBytes\u0026#34;:269490393088}},{\u0026#34;name\u0026#34;:\u0026#34;heapMemory\u0026#34;,\u0026#34;state\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;status\u0026#34;:\u0026#34;UP\u0026#34;,\u0026#34;data\u0026#34;:{\u0026#34;free\u0026#34;:\u0026#34;68.51 MB\u0026#34;,\u0026#34;freeBytes\u0026#34;:71841744,\u0026#34;max\u0026#34;:\u0026#34;1.54 GB\u0026#34;,\u0026#34;maxBytes\u0026#34;:1648361472,\u0026#34;percentFree\u0026#34;:\u0026#34;97.87%\u0026#34;,\u0026#34;total\u0026#34;:\u0026#34;102.00 MB\u0026#34;,\u0026#34;totalBytes\u0026#34;:106954752}}]} # Metrics $ curl http://localhost:8080/metrics --header \u0026#39;Accept:application/json\u0026#39; {\u0026#34;base\u0026#34;:{\u0026#34;classloader.loadedClasses.count\u0026#34;:3881,\u0026#34;classloader.loadedClasses.total\u0026#34;:3884,\u0026#34;classloader.unloadedClasses.total\u0026#34;:0,\u0026#34;cpu.availableProcessors\u0026#34;:8,\u0026#34;cpu.systemLoadAverage\u0026#34;:0.26,\u0026#34;gc.time;name=G1 Old Generation\u0026#34;:0,\u0026#34;gc.time;name=G1 Young Generation\u0026#34;:17,\u0026#34;gc.total;name=G1 Old Generation\u0026#34;:0,\u0026#34;gc.total;name=G1 Young Generation\u0026#34;:1,\u0026#34;jvm.uptime\u0026#34;:118654,\u0026#34;memory.committedHeap\u0026#34;:106954752,\u0026#34;memory.maxHeap\u0026#34;:1648361472,\u0026#34;memory.usedHeap\u0026#34;:38256688,\u0026#34;thread.count\u0026#34;:20,\u0026#34;thread.daemon.count\u0026#34;:15,\u0026#34;thread.max.count\u0026#34;:20},\u0026#34;vendor\u0026#34;:{\u0026#34;requests.count\u0026#34;:2,\u0026#34;requests.meter\u0026#34;:{\u0026#34;count\u0026#34;:2,\u0026#34;meanRate\u0026#34;:0.016974990693588664,\u0026#34;oneMinRate\u0026#34;:0.006394042634681005,\u0026#34;fiveMinRate\u0026#34;:0.002751971906724164,\u0026#34;fifteenMinRate\u0026#34;:0.0010423449272394232}}} Maven を使う 以下、Maven, Gradle を使う場合についても参考程度に載せておきます。\nプロジェクトを生成します。\n$ mvn -U archetype:generate -DinteractiveMode=false \\  -DarchetypeGroupId=io.helidon.archetypes \\  -DarchetypeArtifactId=helidon-quickstart-se \\  -DarchetypeVersion=2.2.0 \\  -DgroupId=io.helidon.examples \\  -DartifactId=helidon-quickstart-se \\  -Dpackage=io.helidon.examples.quickstart.se 中身を覗いてみると以下のようになっています。\n$ tree . ├── Dockerfile # 実行可能JARを生成するDockerfile ├── Dockerfile.jlink # jlinkを使用してビルドするDockerfile ├── Dockerfile.native # Native Imageを生成するDockerfile ├── README.md ├── app.yaml # Kubernetesのマニフェストファイル ├── pom.xml └── src ├── main │ ├── java │ │ └── io │ │ └── helidon │ │ └── examples │ │ └── quickstart │ │ └── se │ │ ├── GreetService.java │ │ ├── Main.java │ │ └── package-info.java │ └── resources │ ├── META-INF │ │ └── native-image │ │ └── reflect-config.json │ ├── application.yaml │ └── logging.properties └── test └── java └── io └── helidon └── examples └── quickstart └── se └── MainTest.java 18 directories, 13 files CLI から生成した時には、Kubernetes のマニフェストファイルや各種 Dockerfile は生成されなかったですが、これは便利そうですね。残りは、全て CLI から生成した場合と同じでした。\nGradle を使う Helidon のサンプルはほとんどが Maven を使用していますが、Gradle も同様に使用することができます。(推奨は、Gradle 6+)Gradle を使用してビルドしたい場合は、Helidon SE の QuickStartに含まれるbuild.gradleを参考にするとよいです。\nbuild.gradle\n/* * Copyright (c) 2018, 2020 Oracle and/or its affiliates. All rights reserved. * * Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \u0026#34;AS IS\u0026#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ apply plugin: \u0026#39;java\u0026#39; group = \u0026#39;io.helidon.examples\u0026#39; // 自分のアプリケーションに合わせて修正する version = \u0026#39;1.0-SNAPSHOT\u0026#39; description = \u0026#34;helidon-quickstart-se\u0026#34; // 自分のアプリケーションに合わせて修正する  sourceCompatibility = 11 targetCompatibility = 11 tasks.withType(JavaCompile) { options.encoding = \u0026#39;UTF-8\u0026#39; } ext { helidonversion = \u0026#39;2.2.0\u0026#39; } test { useJUnitPlatform() } repositories { mavenCentral() mavenLocal() } dependencies { // import Helidon BOM  implementation enforcedPlatform(\u0026#34;io.helidon:helidon-dependencies:${project.helidonversion}\u0026#34;) implementation \u0026#39;io.helidon.webserver:helidon-webserver\u0026#39; implementation \u0026#39;io.helidon.media:helidon-media-jsonp\u0026#39; implementation \u0026#39;io.helidon.config:helidon-config-yaml\u0026#39; implementation \u0026#39;io.helidon.health:helidon-health\u0026#39; implementation \u0026#39;io.helidon.health:helidon-health-checks\u0026#39; implementation \u0026#39;io.helidon.metrics:helidon-metrics\u0026#39; testImplementation \u0026#39;org.junit.jupiter:junit-jupiter-api\u0026#39; testImplementation \u0026#39;io.helidon.webclient:helidon-webclient\u0026#39; testRuntimeOnly \u0026#39;org.junit.jupiter:junit-jupiter-engine\u0026#39; } // define a custom task to copy all dependencies in the runtime classpath // into build/libs/libs // uses built-in Copy task copyLibs(type: Copy) { from configurations.runtimeClasspath into \u0026#39;build/libs/libs\u0026#39; } // add it as a dependency of built-in task \u0026#39;assemble\u0026#39; copyLibs.dependsOn jar assemble.dependsOn copyLibs // default jar configuration // set the main classpath // add each jar under build/libs/libs into the classpath jar { archiveFileName = \u0026#34;${project.name}.jar\u0026#34; manifest { attributes (\u0026#39;Main-Class\u0026#39;: \u0026#39;io.helidon.examples.quickstart.se.Main\u0026#39;, // 自分のアプリケーションの構造に合わせて修正してください  \u0026#39;Class-Path\u0026#39;: configurations.runtimeClasspath.files.collect { \u0026#34;libs/$it.name\u0026#34; }.join(\u0026#39; \u0026#39;) ) } } ビルドはおなじみのコマンドで。\n$ gradle build 終わりに 今回は、プロジェクトの生成までを一通りやってみました。次回以降公式ドキュメントに記載されているコンポーネントを順番に試していきたいと思います。\n今回作成したソースコードはこちらのリポジトリに格納しています。\n参考  Helidon 公式ドキュメント  ","ref":"/blog/blog/2021/0206-helidon-se-get-started/"},{"title":"Nest.jsで接続先情報を環境変数から非同期で取得する","date":"","description":"","body":"始めに ※ブログを一か所にまとめるため、以前 Qiita に投稿した記事の移行しています。\nNest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。\n環境  Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6  実装手順 必要最小限の実装 参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt;Database\nライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。\n$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。\nimport { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ItemModule } from \u0026#34;./item/item.module\u0026#34;; import { Connection } from \u0026#34;typeorm\u0026#34;; import { join } from \u0026#34;path\u0026#34;; @Module({ imports: [ ItemModule, // DBの接続情報を定義  TypeOrmModule.forRoot({ type: \u0026#34;postgres\u0026#34;, host: \u0026#34;localhost\u0026#34;, port: 5432, username: \u0026#34;postgres\u0026#34;, password: \u0026#34;postgres\u0026#34;, database: \u0026#34;postgres\u0026#34;, entities: [join(__dirname + \u0026#34;/**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }), ], }) export class AppModule {} 一番シンプルな書き方です。自分一人しか触らず、環境もこれだけ！ということであればこの書き方で良いでしょう。\nしかし、実際の開発では個人の開発環境、テスト環境、ステージング環境、本番環境と複数の環境が存在し、上記のような実装では環境ごとに接続情報をハードコードし直し → ビルド → デプロイという手順を踏む必要がありナンセンスです。\nそのため、通常は環境変数に定義し、接続情報はその環境変数を参照し作成します。\nと、いうことで環境変数を参照するようにapp.module.tsを修正します。\n【失敗】環境変数を参照するように実装を修正 ※この方法では実行時に依存関係が解決できずエラーとなります。\n参考）Nest.js Document \u0026gt; TECHNIQUES \u0026gt; Configuration\nライブラリインストール 環境変数を参照するために必要なライブラリをインストールします。\n$ npm install @nestjs/config ダミーの環境変数を用意 本来は、環境変数に定義するのですがサンプル実装なので環境変数ファイル（.env）をプロジェクトルートに作成します。\nDATABASE_HOST=localhost DATABASE_PORT=5432 DATABASE_USERNAME=postgres DATABASE_PASSWORD=postgres DATABASE_NAME=postgres 環境変数を参照するように接続定義を修正 import { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ConfigModule, ConfigService } from \u0026#34;@nestjs/config\u0026#34;; import { Connection } from \u0026#34;typeorm\u0026#34;; import { join } from \u0026#34;path\u0026#34;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#34;.env\u0026#34;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), // 非同期で環境変数から値を取得し、接続情報を作成する。  TypeOrmModule.forRootAsync({ imports: [ConfigModule], useFactory: async (configService: ConfigService) =\u0026gt; ({ type: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, host: configService.get(\u0026#34;DATABASE_HOST\u0026#34;), port: Number(configService.get(\u0026#34;DATABASE_HOST\u0026#34;)), username: configService.get(\u0026#34;DATABASE_USERNAME\u0026#34;), password: configService.get(\u0026#34;DATABASE_PASSWORD\u0026#34;), database: configService.get(\u0026#34;DATABASE_NAME\u0026#34;), entities: [join(__dirname + \u0026#34;/**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }), inject: [ConfigService], }), ], }) export class AppModule { constructor(private readonly connection: Connection) {} } 起動後、以下のエラーが発生。\n2:25:34 PM - Found 0 errors. Watching for file changes. [Nest] 19111 - 01/13/2020, 2:25:35 PM [NestFactory] Starting Nest application... [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] TypeOrmModule dependencies initialized +24ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [InstanceLoader] ConfigModule dependencies initialized +1ms [Nest] 19111 - 01/13/2020, 2:25:35 PM [ExceptionHandler] Nest can\u0026#39;t resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) +1ms Error: Nest can\u0026#39;t resolve dependencies of the TypeOrmModuleOptions (?). Please make sure that the argument ConfigService at index [0] is available in the TypeOrmCoreModule context. Potential solutions: - If ConfigService is a provider, is it part of the current TypeOrmCoreModule? - If ConfigService is exported from a separate @Module, is that module imported within TypeOrmCoreModule? @Module({ imports: [ /* the Module containing ConfigService */ ] }) at Injector.lookupComponentInExports (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:185:19) at processTicksAndRejections (internal/process/task_queues.js:94:5) at async Injector.resolveComponentInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:142:33) at async resolveParam (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:96:38) at async Promise.all (index 0) at async Injector.resolveConstructorParams (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:111:27) at async Injector.loadInstance (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:78:9) at async Injector.loadProvider (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/injector.js:35:9) at async Promise.all (index 3) at async InstanceLoader.createInstancesOfProviders (/home/kawamura/docker/docker-services/sample-app/sample-back/node_modules/@nestjs/core/injector/instance-loader.js:41:9) 環境変数を参照するためのConfigServiceがTypeOrmModuleOptions内で依存関係が解決できないことが原因らしい。\n同じような事象が Github の Issue にあがっていたので参考に載せておきます。\nCan\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n【成功】環境変数を参照するように実装を修正 app.module.tsを以下のように修正します。\nimport { Module } from \u0026#34;@nestjs/common\u0026#34;; import { TypeOrmModule } from \u0026#34;@nestjs/typeorm\u0026#34;; import { ConfigModule } from \u0026#34;@nestjs/config\u0026#34;; import { TypeOrmConfigService } from \u0026#34;./common/database/type-orm-config.service\u0026#34;; @Module({ imports: [ ConfigModule.forRoot({ envFilePath: \u0026#34;.env\u0026#34;, isGlobal: true, // ignoreEnvFile: true, \u0026lt;- 環境変数から取得する場合はコメントアウトを外す。  }), TypeOrmModule.forRootAsync({ imports: [ConfigModule], // 接続情報を作成するServiceクラスを定義  useClass: TypeOrmConfigService, }), ], }) export class AppModule {} 接続情報を作成する Service クラスを生成します。\nimport { TypeOrmOptionsFactory, TypeOrmModuleOptions } from \u0026#34;@nestjs/typeorm\u0026#34;; import { Injectable } from \u0026#34;@nestjs/common\u0026#34;; import { ConfigService } from \u0026#34;@nestjs/config\u0026#34;; import { join } from \u0026#34;path\u0026#34;; /** * DBの接続情報を作成するServiceクラスです。 */ @Injectable() export class TypeOrmConfigService implements TypeOrmOptionsFactory { /** * DBの接続設定を環境変数をもとに作成します。 * 環境変数に設定されていない場合は、デフォルトの設定値を返却します。 * @returns 接続情報 */ createTypeOrmOptions(): TypeOrmModuleOptions { const configService = new ConfigService(); return { type: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, host: configService.get(\u0026#34;DATABASE_HOST\u0026#34;, \u0026#34;localhost\u0026#34;), port: Number(configService.get(\u0026#34;DATABASE_PORT\u0026#34;, 5432)), username: configService.get(\u0026#34;DATABASE_USERNAME\u0026#34;, \u0026#34;postgres\u0026#34;), password: configService.get(\u0026#34;DATABASE_PASSWORD\u0026#34;, \u0026#34;postgres\u0026#34;), database: \u0026#34;postgres\u0026#34; as \u0026#34;postgres\u0026#34;, entities: [join(__dirname + \u0026#34;../**/*.entity{.ts,.js}\u0026#34;)], synchronize: false, }; } } ConfigServiceを DI するのではなく、自分で new するのがポイントです。\n最後に 今回のサンプル実装はこちらのリポジトリで公開しています。\n最近使い始めたのですが、素晴らしいフレームワークだとひしひしと感じております。 フレームワーク自体の良さはこちらの記事で紹介されています。\n参考   NestJs 公式ドキュメント\n  Can\u0026rsquo;t init TypeOrmModule using factory and forRootAsync\n  Nest.js は素晴らしい\n  ","ref":"/blog/blog/2020/0911-nestjs-async-multiple-db-connection/"},{"title":"Hugo + GitHub Pagesでブログを始めた","date":"","description":"","body":"始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。\nこのブログについて 環境  静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages  という環境で、作成し運用されています。\n選定理由 いくつか背景があるので、順にお話します。\nQiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。\n静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc \u0026hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。\nホスティング先 ホスティング先には、いくつか条件がありました。\n 無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと  これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。\ndocs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。\n\u0026gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.co/NCVgnMOonq\n\u0026mdash; peaceiris (@piris314) September 6, 2020  どうやら、Hugo で生成されるファイル群をバージョン管理する方法ではなく、GitHub Actinos で静的ファイルを任意のブランチに生成し、そのブランチを GitHub Pages へデプロイするという方法があるようです。\nブログの作り方 前置きが長くなってしまいましたが、当ブログの作り方を簡単に説明したいと思います。\n 省エネ、基本的に無料でブログを書きたい人 自分でデザインしないと満足できない人  には、お勧めできる方法だと思います。尚、テーマのカスタマイズや自作方法については当記事では触れないので悪しからず。\n環境構築 Windows 10 を使用しています。Chocolatey, Scoop といったパッケージマネージャーを使用する方法と zip を展開してパスを通す方法がありますが、今回紹介するのは後者の方法です。\nhttps://github.com/gohugoio/hugo/releasesから最新版の zip ファイルをダウンロードし適用なディレクトリに解凍します。\n同じバージョンでも通常版（hugo）と Extended 版（hugo_extended）と 2 種類ありますが、後ほど紹介する公開されているテーマを使用する場合はExtended 版の方を選択してください。（Extended 版の方は、SASS/SCSS が使用できます。公開されているテーマで SASS/SCSS が使用されている場合、通常の hugo ではエラーが発生し静的ファイルの生成ができません。）\n次に、パスを通します。システム環境変数からPathを選択し、先ほど解凍したディレクトリを指定します。\n$ hugo version Hugo Static Site Generator v0.74.3/extended windows/amd64 BuildDate: unknown この様に表示されれば、環境構築は完了です。\nブログを生成する 適当なディレクトリで以下のように入力する。\n$ hugo new site blog Congratulations! Your new Hugo site is created in C:\\Git\\test\\blog. Just a few more steps and you\u0026#39;re ready to go: 1. Download a theme into the same-named folder. Choose a theme from https://themes.gohugo.io/ or create your own with the \u0026#34;hugo new theme \u0026lt;THEMENAME\u0026gt;\u0026#34; command. 2. Perhaps you want to add some content. You can add single files with \u0026#34;hugo new \u0026lt;SECTIONNAME\u0026gt;\\\u0026lt;FILENAME\u0026gt;.\u0026lt;FORMAT\u0026gt;\u0026#34;. 3. Start the built-in live server via \u0026#34;hugo server\u0026#34;. Visit https://gohugo.io/ for quickstart guide and full documentation. テーマを選定する https://themes.gohugo.io/にいい感じのテーマが沢山あるので好きなものを選びます。（ここでは仮に、Hugo Future Imperfect Slimを選択したとする）Download ボタンを押すと、GitHub のリポジトリトップに遷移するので、README を読みながら設定を進めます。\nテーマのインストール テーマは Git の Submodule として管理するのが主流みたいです。\n$ cd blog/themes $ git submodule add https://github.com/pacollins/hugo-future-imperfect-slim.git $ git submodule update --remote --merge 設定ファイルをコピーし修正する サンプルサイトの設定ファイル（config.toml, staticman.yml）を自サイトのルートにコピーします。\n$ cp ./hugo-future-imperfect-slim/exampleSite/config.toml ../ $ cp ./hugo-future-imperfect-slim/exampleSite/staticman.yml ../ この手の設定は、自分で動かしながら変えていくのが手っ取り早いかなと思いました。（分からない所だけドキュメントを参照する）\nGitHub Pages で公開する .github/workflows/gh-pages.ymlを作成する。詳細な説明は、リポジトリを参照してください。\nname: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;0.74.2\u0026#34; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./docs 後は、master に push すればhttps://\u0026lt;github username\u0026gt;.github.io/\u0026lt;repository name\u0026gt;として公開されます！\n終わりに 細かい個所などは紹介できていないので、詳細が気になる方はリポジトリを参照してください。\n参考  https://gohugo.io/ https://github.com/peaceiris/actions-hugo https://github.com/shukawam/blog  ","ref":"/blog/blog/2020/0909-about-this-blog/"},{"title":"","date":"","description":"","body":"始めに FIDO2 による認証を Oracle の Identity Provider である IDCS(Oracle Identity Provider Service)を使ってさくっと作ってみます。IDCS は、Always Free でも触ることができるので是非試してみてください！\n環境 構成図にも記載していますが、今回は\n Authenticator: Yubikey Client: IDCS 提供の画面 + α(認証成功後にリダイレクトされる画面等) Relying Party: Oracle Identity Cloud Service  という構成となっています。手元に認証器がない方は、Chrome の拡張の Virtual Authenticators Tab で代用可能です。\n手順 IDCS のセットアップ Service Request を申請する OCI 契約時に自動的に含まれている IDCS では、FIDO Authenticator を使用したパスワードレス認証／MFA を使用することができないので、Service Request を申請し、機能の制限を解除してもらう必要があります。\n詳しくはこちらをご参照ください。\nManage Passwordless Authentication\nGroup を作成する まずは、登録したユーザーが所属するグループを作成します。\n管理コンソールから、グループ \u0026gt; 追加を押下し、グループを新しく作成します。\n作成するグループは以下のよう。\n現時点では、ユーザーを所属させる必要はないので、このまま終了を押し、グループの作成を完了させます。\n自己登録プロファイルを作成する ユーザーのセルフサインアップを行うために、自己登録プロファイルを作成します。\n管理コンソールから、設定 \u0026gt; 自己登録 \u0026gt; 追加を押下し、グループを新しく作成します。\n以下のように入力し、プロファイルを作成します。\n先ほど、作成したグループを割り当てる事で、このプロファイルに基づき登録されたユーザーが作成したグループ(FIDO)に所属するようになります。\nApplication を作成する ID 管理を行う単位であるアプリケーションを作成します。\n管理コンソールから、アプリケーション \u0026gt; 追加を押し、アプリケーションを作成します。\n機密アプリケーションを選択します。\nその後、以下のように入力しアプリケーションを作成します。(記載のない内容については未入力で大丈夫です)\n 詳細  名前: FIDO   クライアント  許可される権限付与タイプ: クライアント資格証明、JWT アサーション、認可コード HTTPS 以外の URL を許可にチェック リダイレクト URL: http://localhost/login-success.html   リソース  IdP ポリシーを作成する アプリケーションに設定する ID 管理のためのポリシー(ユーザーの認証方法 etc.)を設定します。\nサインオンポリシーを作成する アプリケーションに設定するユーザーの認証時のポリシーを設定します。今回は、\n Username/Password を用いて認証したユーザーに対しては、2 番目の要素として FIDO 認証器による認証を強制する FIDO の認証器を用いて認証したユーザーはそのまま認証可能(パスワードレス)  というポリシーを設定したいと思います。\n認証成功後にリダイレクトされる画面を作成する 簡単な画面を作ったのでこちらをご活用ください。\ngit clone https://github.com/shukawam/xxx.git 終わりに 初めて触る方にとっては、想像したよりも簡単に生体認証を導入することができたのではないでしょうか。今回は、Identity Provider が FIDO2 の Relying Party を代わりに実装している形式で試してみましたが、学習がてら自分で実装してみたい方はこちらも参考にしてみてください。\nHelidon MP, WebAuthn4J で FIDO2(WebAuthn)\n","ref":"/blog/qiita/get-started-fido2-with-idcs/get-started-fido2-with-idcs/"}]