<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Shukawam's Daily Blog</title><link>https://shukawam.github.io/blog/blog/</link><description>Recent content in Blogs on Shukawam's Daily Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 06 Apr 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://shukawam.github.io/blog/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>FIDO2 Tips &amp; Considering</title><link>https://shukawam.github.io/blog/blog/2021/0406-webauthn-tips/</link><pubDate>Tue, 06 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0406-webauthn-tips/</guid><description>始めに FIDO2 をアプリケーションに組み込むときのちょっとした Tips や考慮しないといけないことを思いつくままにまとめてみようと思います。思いつく＆何か新しい発見があるたびに記事は随時更新していきます。
Tips Virtual Authenticators Tab まずは、Chrome の拡張機能の紹介です。組織のポリシーなどで会社支給のパソコンからinternalの認証器が呼び出せないパターンもあるでしょう。例えば、デモやちょっとした検証をやりたいのにわざわざそのために USB セキュリティキーを買うのもちょっと馬鹿らしいですよね。そんな時に非常に役に立ちます。
使い方自体は非常に簡単で、まずは chrome ウェブストア - Virtual Authenticators Tabで当該機能を有効化する。
Virtual Authenticators Tab を追加しますか？ というポップアップが出てくるので、拡張機能を追加 を押して追加する。
確認には、おなじみのwebauthn.ioが良いと思います。
まずは、DevTool を開き追加されているVirtual Authenticators内にあるEnable Virtual Authenticator Environmentのチェックボックスにチェックを入れます。
後は、お好きな仮想認証器を生成してください。一応、設定できるパラメータを解説すると
Protocol ctap2 CTAP1 を FIDO2 用に拡張したもの u2f CTAP1 のことでクライアントと外部認証器との通信プロトコルのこと 選択肢では、internalが選択できそうですが、作成の際にエラーメッセージが出力されます Transport usb USB セキュリティキーのこと(e.g. Yubikey) nfc Near Field Communication(e.g. Suica, Pasmo) ble Bluetooth Smart/Bluetooth Low Energy Technology internal プラットフォームの認証器のこと(e.</description></item><item><title>WebAuthn DeepDive #2 - Attestation</title><link>https://shukawam.github.io/blog/blog/2021/0404-webauthn-deep-dive/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0404-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。
About Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。
Deep Dive まずは、原文を読んでみましょう。
Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision.</description></item><item><title>WebAuthn DeepDive #1 - navigator.credentials.create()</title><link>https://shukawam.github.io/blog/blog/2021/0324-webauthn-deep-dive/</link><pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0324-webauthn-deep-dive/</guid><description>始めに WebAuthn について学習したときのメモ。今回は、WebAuthnよりも CTAP の話が多めかも。
Deep Dive この辺の仕様を読んでいく。
※図はhttps://developer.mozilla.org/ja/docs/Web/API/Web_Authentication_APIから参照
全体の流れとしては、
navigator.credentials.create()が実行される authenticatorMakeCredential()を実行するためのパラメータを組み立てる 認証器のauthenticatorMakeCredential()が呼び出される authenticatorMakeCredential()を実行した結果がブラウザに返される となっています。WebAuthn が実行され、認証器のauthenticatorMakeCredential()が呼び出される所から順番に見ていきます。
2. navigator.credentials.create()の実行 navigator.credentials.create()が呼び出されると、認証器のauthenticatorMakeCredential()を実行するためのパラメータを組み立てて実行します。その際、authenticatorMakeCredential()実行のために必要なパラメータの仕様は、こちらに公開されています。一部抜粋して読んでいきたいと思います。(ひとまず今回は、Required のものだけ確認していきます)
パラメータ名 型 概要 clientDataHash Byte Array clientData のハッシュ rp PublicKeyCredentialRpEntity Relying Party の情報 user PublicKeyCredentialUserEntity 新しく生成する Credential に紐づくユーザーの情報 pubKeyCredParams CBOR Array 生成する Credential のパラメータ(type: public-keyで固定, alg: 公開鍵の暗号化アルゴリズム) clientDataHash Hash of the ClientData contextual binding specified by host.</description></item><item><title>Spring Native Getting Started</title><link>https://shukawam.github.io/blog/blog/2021/0322-spring-boot-native-image/</link><pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0322-spring-boot-native-image/</guid><description>始めに Spring Nativeを使って、Spring Boot アプリケーションを Native Image 化してみます。
手順 Spring Initializr を使用してひな形を作成します。今回は、Helath Check のエンドポイントを一つ有するアプリケーションを作成します。
curl -G https://start.spring.io/starter.zip -o spring-boot-native-image-sample.zip -d javaVersion=11 -d dependencies=web,actuator,native % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 57164 100 57164 0 0 106k 0 --:--:-- --:--:-- --:--:-- 106k 解凍します。
unzip spring-boot-native-image-sample.zip -d spring-boot-native-image Archive: spring-boot-native-image-sample.zip inflating: spring-boot-native-image/.gitignore inflating: spring-boot-native-image/HELP.md inflating: spring-boot-native-image/mvnw creating: spring-boot-native-image/src/ creating: spring-boot-native-image/src/main/ creating: spring-boot-native-image/src/main/java/ creating: spring-boot-native-image/src/main/java/com/ creating: spring-boot-native-image/src/main/java/com/example/ creating: spring-boot-native-image/src/main/java/com/example/demo/ inflating: spring-boot-native-image/src/main/java/com/example/demo/DemoApplication.</description></item><item><title>Helidon SE Component - Config, OpenAPI</title><link>https://shukawam.github.io/blog/blog/2021/0212-helidon-se-components/</link><pubDate>Mon, 08 Feb 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0212-helidon-se-components/</guid><description>始めに Java の軽量フレームワークの一つであるHelidonの全コンポーネントを触っていくエントリーの一回目です。本日は、
Config OpenAPI について触っていこうと思います。
Components Config 様々なソース(.properties, .yaml, .json)から Config オブジェクトに設定プロパティをロードして処理するための Java API を提供します 各種設定情報をソースコードから分離することでコード自体の保守性を向上させたりする目的があります 早速、試していきます。CLI を使用してひな形を生成した場合は、自動的に Config 関連の依存関係が含まれていますが、含まれていない場合は以下をpom.xmlに追加します。
pom.xml
&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;io.helidon.config&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;helidon-config-yaml&amp;lt;/artifactId&amp;gt; &amp;lt;/dependency&amp;gt; 今回は、yaml形式で記載したいと思います。jsonでもpropertiesでも結果は同じですが個人的にyamlが好きだからです。（一番無駄がないし、視認性もよい）
resources/application.yamlに Config オブジェクトにマッピングさせる情報を記載していきます。
application.yaml
app: greeting: &amp;#34;Hello&amp;#34; config: &amp;#34;config service works!!&amp;#34; # 追記 server: port: 8080 host: 0.0.0.0 application.yamlに記載した項目を参照するには以下のようにします。
var config = Config.create(); var value = config.get(&amp;#34;app.config&amp;#34;).asString().orElse(&amp;#34;config service NOT work&amp;#34;); OpenAPI OpenAPI 仕様のドキュメントを生成するエンドポイントを容易に生成することができる Eclipse MicroProfile の OpenAPI 仕様となっているので、実装などで困った際は Helidon のドキュメントではなく、MicroProfile の OpenAPI 仕様のドキュメントを参考にするとよい 早速、試していきます。まずは、OpenAPI 関連の依存関係をpom.</description></item><item><title>Helidon SE Get Started</title><link>https://shukawam.github.io/blog/blog/2021/0206-helidon-se-get-started/</link><pubDate>Sun, 07 Feb 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0206-helidon-se-get-started/</guid><description>始めに Java の軽量フレームワークの一つである Helidon を何回かに分けて全コンポーネントを触ってみたいと思います。尚、Helidon には
Helidon SE: 軽量でフットプリント重視 Helidon MP: Eclipse MicroProfile との互換性や機能性を重視 と、エディションが二つ存在しますが、一旦は SE の方に注目して触っていきたいと思います。(SE のコンポーネントを一通り試し終わったら、MP も同様に試していきます。) 今回は、アプリケーションの生成までをやっていきます。
環境 一応、私の環境情報を載せておきます。
OS: Windows 10(WSL2 で Ubuntu 18.04 を使用しています) Java: OpenJDK 11 手順 Helidon CLI を使う アプリケーションのひな型生成や開発モード（ソースコードの変更を再度ビルドする必要なく即時反映してくれる仕組み）をサポートしている便利ツールです。2021/02/06 現在、Windows はまだ CLI の配布がされていないため、ローカルで CLI を使用したい場合は、WSL2 で Ubuntu を使うなどのひと工夫が必要です。
インストール自体は、非常に簡単でバイナリをダウンロードしてパスが通っているところにインストールするだけで大丈夫です。
$ curl -O https://helidon.io/cli/latest/linux/helidon $ chmod +x ./helidon $ sudo mv ./helidon /usr/local/bin/ とりあえず、どんなことができるかを見ておきます。
$ helidon --help Usage: helidon [OPTIONS] COMMAND Helidon Project command line tool Options: -D&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; Define a system property --verbose Produce verbose output --debug Produce debug output --plain Do not use color or styles in output Commands: build Build the application dev Continuous application development info Print project information init Generate a new project version Print version information Run &amp;#39;helidon COMMAND --help&amp;#39; for more information on a command.</description></item><item><title>Nest.jsで接続先情報を環境変数から非同期で取得する</title><link>https://shukawam.github.io/blog/blog/2020/0911-nestjs-async-multiple-db-connection/</link><pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2020/0911-nestjs-async-multiple-db-connection/</guid><description>始めに ※ブログを一か所にまとめるため、以前 Qiita に投稿した記事の移行しています。
Nest.js で環境ごとにデータベースの接続先を分けるために、接続情報を実行環境の環境変数から非同期で取得するサンプルを作成します。
環境 Node.js v12.14.1 Nest.js v6.7.2 TypeORM v0.2.22 PostgreSQL v11.6 実装手順 必要最小限の実装 参考）Nest.js Document &amp;gt; TECHNIQUES &amp;gt;Database
ライブラリインストール TypeORM, Database Driver (PostgreSQL)をインストールする。
$ npm install @nestjs/typeorm typeorm pg DB 接続情報を定義 app.module.tsにデータベースの接続情報を定義する。
import { Module } from &amp;#34;@nestjs/common&amp;#34;; import { TypeOrmModule } from &amp;#34;@nestjs/typeorm&amp;#34;; import { ItemModule } from &amp;#34;./item/item.module&amp;#34;; import { Connection } from &amp;#34;typeorm&amp;#34;; import { join } from &amp;#34;path&amp;#34;; @Module({ imports: [ ItemModule, // DBの接続情報を定義 TypeOrmModule.</description></item><item><title>Hugo + GitHub Pagesでブログを始めた</title><link>https://shukawam.github.io/blog/blog/2020/0909-about-this-blog/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2020/0909-about-this-blog/</guid><description>始めに つい先日、Qiita からはてなブログに移行したばかりだったのですが、個人的に何点か気に食わない点があったので自分で作って運用してみることにしました。 この記事は実際にブログを作ってみた時のお話です。
このブログについて 環境 静的サイトジェネレーター：Hugo Static Site Generator v0.74.3 運用（ホスティング）：GitHub Pages という環境で、作成し運用されています。
選定理由 いくつか背景があるので、順にお話します。
Qiita, はてなブログじゃダメだった理由 Markdown で記載できるブログあるあるだと思うのですが、とにかく画像のアップロードがめんどくさい。他にも、デザインが気に食わなかったりなど細かい理由はありますが、理由の 9 割はこれでした。自分のメモ、ついでに外部発信くらいと考えてる人にとってはなるべく省エネで執筆したかったのです。
静的サイトジェネレーター このブログは、Golang 謹製のHugoを使用して作成しています。Hugo 以外の有名どころだと、Gatsby, Hexo, Jekyll etc &amp;hellip; 辺りがありますが、正直何でも良かったです。環境構築が非常に楽という噂を聞きつけたので、Hugo を採用しました。（他のものは試してすらないです）実際、私の PC は Windows 10 なのですが、環境構築～このブログを作成するまで 1 時間程度でできました。
ホスティング先 ホスティング先には、いくつか条件がありました。
無料で運用できること インフラ（サーバ）の面倒を見なくてもいいこと これらを加味した結果、ホスティング先は GitHub Pages or GitLab Pages に絞られました。最初は、Hugo によって生成されるコンテンツを管理したくなかったので、GitLab Pages にしようと思っていましたが、個人的に GitLab から GitHub に移行したばかりだったので少し微妙だなと思ったことをツイートしたのですが、こんな回答をいただけました。
docs/ を管理する方法以外に、任意のブランチをデプロイに使う方法があります。参考になれば幸いです。
&amp;gt; Deploy Hugo site to GitHub Pages with GitHub Actionshttps://t.</description></item></channel></rss>