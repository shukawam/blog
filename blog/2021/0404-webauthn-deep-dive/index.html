<!doctype html><html lang=en-us><head><title>WebAuthn DeepDive #2 - Attestation // Shukawam's Daily Blog</title><link rel="shortcut icon" href=/favicon.ico><meta charset=utf-8><meta name=generator content="Hugo 0.74.2"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Shuhei Kawamura"><meta name=description content><link rel=stylesheet href=https://shukawam.github.io/blog/css/main.min.8319a554a1447263053ca3a53200e173393626a2b845544492b7de792c2e9412.css><meta name=twitter:card content="summary"><meta name=twitter:title content="WebAuthn DeepDive #2 - Attestation"><meta name=twitter:description content="始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。
About Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。
Deep Dive まずは、原文を読んでみましょう。
 Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision."><meta property="og:title" content="WebAuthn DeepDive #2 - Attestation"><meta property="og:description" content="始めに WebAuthn について学習したときのメモ。今回は、Attestation についてです。
About Attestation 雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。
Deep Dive まずは、原文を読んでみましょう。
 Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision."><meta property="og:type" content="article"><meta property="og:url" content="https://shukawam.github.io/blog/blog/2021/0404-webauthn-deep-dive/"><meta property="article:published_time" content="2021-04-05T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-05T00:00:00+00:00"><script async src="https://www.googletagmanager.com/gtag/js?id=G-4W6XCC73C8"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','G-4W6XCC73C8');</script></head><body><header class=app-header><a href=https://shukawam.github.io/blog><img class=app-header-avatar src=/blog/img/main/shukawam.jpg alt="Shuhei Kawamura"></a><h1>Shukawam's Daily Blog</h1><nav class=app-header-menu><a class=app-header-menu-item href=/blog/>Home</a>
-
<a class=app-header-menu-item href=/blog/tags/>Tags</a></nav><p>I'm Solutions Engineer at Oracle Japan. These articles are just my opinions.</p><div class=app-header-social><a href=https://github.com/shukawam target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github"><title>Github</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77a5.44 5.44.0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a><a href=https://twitter.com/shukawam target=_blank rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter"><title>Twitter</title><path d="M23 3a10.9 10.9.0 01-3.14 1.53 4.48 4.48.0 00-7.86 3v1A10.66 10.66.0 013 4s-4 9 5 13a11.64 11.64.0 01-7 2c9 5 20 0 20-11.5a4.5 4.5.0 00-.08-.83A7.72 7.72.0 0023 3z"/></svg></a></div></header><main class=app-container><article class=post><header class=post-header><h1 class=post-title>WebAuthn DeepDive #2 - Attestation</h1><div class=post-meta><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar"><title>calendar</title><rect x="3" y="4" width="18" height="18" rx="2" ry="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>Apr 5, 2021</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock"><title>clock</title><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>2 min read</div><div><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag"><title>tag</title><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7.01" y2="7"/></svg><a class=tag href=https://shukawam.github.io/blog/tags/webauthn/>webauthn</a>
<a class=tag href=https://shukawam.github.io/blog/tags/ctap/>ctap</a>
<a class=tag href=https://shukawam.github.io/blog/tags/fido2/>fido2</a></div></div></header><div class=post-content><h1 id=始めに>始めに</h1><p><a href=https://webauthn.io/>WebAuthn</a> について学習したときのメモ。今回は、<a href=https://www.w3.org/TR/webauthn-1/#sctn-attestation>Attestation</a> についてです。</p><h1 id=about-attestation>About Attestation</h1><p>雑に言うと、FIDO2 のユーザー登録フローにおいて認証器で非対称の鍵ペア(秘密鍵、公開鍵)が生成されるが、その公開鍵がきちんと FIDO2 認証ベンダーの認証器から生成されたものか？どうかを検証する仕組みのこと。認証器は出荷時に FIDO2 認定ベンダーより認証器内のセキュア領域にベンダー固有の秘密鍵を埋め込まれるが、その秘密鍵でユーザー登録時に生成した公開鍵に対して署名を行う。最終的に RP(Relying Party)では、その署名をベンダー固有の公開鍵(ルート証明書)を用いる事で検証し、送信されてきた公開鍵の妥当性を検証することでユーザーの登録可否を決定する。</p><h1 id=deep-dive>Deep Dive</h1><p>まずは、原文を読んでみましょう。</p><blockquote><p>Authenticators MUST also provide some form of attestation. The basic requirement is that the authenticator can produce, for each credential public key, an attestation statement verifiable by the WebAuthn Relying Party. Typically, this attestation statement contains a signature by an attestation private key over the attested credential public key and a challenge, as well as a certificate or similar data providing provenance information for the attestation public key, enabling the Relying Party to make a trust decision. However, if an attestation key pair is not available, then the authenticator MUST perform self attestation of the credential public key with the corresponding credential private key. All this information is returned by authenticators any time a new public key credential is generated, in the overall form of an attestation object. The relationship of the attestation object with authenticator data (containing attested credential data) and the attestation statement is illustrated in figure 5, below.</p></blockquote><p>雑に訳すと、</p><ul><li>Authenticator(認証器)は、何らかの認証を提供する必要がある(生成した公開鍵の出所を証明すること)</li><li>Authenticator(認証器)の満たすべき基本的な要件は以下<ul><li>クレデンシャル公開鍵(登録時に生成される公開鍵)について、WebAuthn RP が検証可能な証明書(<code>attestation statement</code>)を作成できる事</li><li><code>attestation statement</code>には以下の情報を含む(RP はこれらの情報を用いて、公開鍵の出所の妥当性を検証を行う)<ul><li>FIDO2 認証ベンダーから認証器内のセキュア領域に埋め込まれた秘密鍵によって生成された署名</li><li>RP から発行された challenge</li><li>公開鍵の出所情報を提供する証明書(もしくはそれに値する情報)</li></ul></li></ul></li></ul><p>となる。何となく、FIDO2 における Attestation がどういうものだか分かってきたので、WebAuthn 実行後に認証器から返却されるデータを振り返ってみましょう。こんなデータが返ってきます。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt>{
  &#34;id&#34;: &#34;xTzphZPuJyfW12TAT…&#34;,
  &#34;rawId&#34;: ArrayBuffer(64) {},
  &#34;response&#34;: {
    &#34;attestationObject&#34;: ArrayBuffer(1024),
    &#34;clientDataJSON&#34;: ArrayBuffer(116) {}
  },
  &#34;type&#34;: &#34;public-key&#34;
}
</code></pre></div><p>今回ちゃんと仕様を読んでいくのは、このうち<code>attestationObject</code>ということになります。</p><h2 id=attestation-object>Attestation Object</h2><p><code>attestationObject</code>は、CBOR<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>で表現されており、W3C で仕様が公開されています。具体的には以下の通り。</p><p><img src=https://shukawam.github.io/blog/img/2021/0404/attestation-object.png alt=attestation-object></p><p>もう少し、開発者に分かりやすく JSON 形式で表現すると以下のようになる。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json>[
  {
    <span style=color:#f92672>&#34;fmt&#34;</span>: <span style=color:#e6db74>&#34;packed&#34;</span>,
    <span style=color:#f92672>&#34;attStmt&#34;</span>: {
      <span style=color:#f92672>&#34;alg&#34;</span>: <span style=color:#ae81ff>-7</span>,
      <span style=color:#f92672>&#34;sig&#34;</span>: {
        <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;Buffer&#34;</span>,
        <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#e6db74>&#34;...&#34;</span>
      },
      <span style=color:#f92672>&#34;x5c&#34;</span>: [
        {
          <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;Buffer&#34;</span>,
          <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#e6db74>&#34;...&#34;</span>
        }
      ]
    },
    <span style=color:#f92672>&#34;authData&#34;</span>: {
      <span style=color:#f92672>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;Buffer&#34;</span>,
      <span style=color:#f92672>&#34;data&#34;</span>: <span style=color:#e6db74>&#34;...&#34;</span>
    }
  }
]
</code></pre></div><p>各プロパティ内に含まれるバイナリデータまで見ていきましょう。</p><h3 id=fmt>fmt</h3><p><a href=https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>Defined Attestation Statement Formats</a>によると、以下の種類があるそうです。</p><table><thead><tr><th>Format</th><th>Attestation Support Type</th><th>説明</th></tr></thead><tbody><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-packed-attestation>Packed</a></td><td>Basic, Self, AttCA</td><td>WebAuthn に最適化されたフォーマット</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-tpm-attestation>TPM</a></td><td>AttCA</td><td>Trusted Platform Module を暗号エンジンとして使用する認証器で使用される</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-android-key-attestation>Android Key</a></td><td>Basic</td><td>対象となる認証器が Android N(Nougat) 移行のプラットフォーム認証器の場合に使用される</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-android-safetynet-attestation>Android SafetyNet</a></td><td>Basic</td><td>認証器が特定の Android プラットフォーム上の認証器の場合、SafetyNet API に基づいても良い</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-fido-u2f-attestation>FIDO U2F</a></td><td>Basic, AttCA</td><td>FIDO U2F 認証器で使用される</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-none-attestation>None</a></td><td>None</td><td>Relying Party が認証情報を受け取ることを希望しない場合に使用する</td></tr><tr><td><a href=https://www.w3.org/TR/webauthn/#sctn-apple-anonymous-attestation>Apple Anonymous</a></td><td>Anonymization CA</td><td>Apple が WebAuthn をサポートする特定の種類の Apple デバイスに対して独占的に使用される</td></tr></tbody></table><p>上の Attestation Object の構造の所で先出ししてしまいましたが、今回は<code>Packed</code>の場合のみ取り扱います。</p><h3 id=attedted-credential-data>Attedted Credential Data</h3><p>下図の赤枠でかこっている箇所の話です。</p><p><img src=https://shukawam.github.io/blog/img/2021/0404/attested_credential_data.png alt=attested-credential-data></p><p><code>authData</code>内に含まれる Attested Credential Data は、以下のような構成になっています。</p><table><thead><tr><th>プロパティ名</th><th>バイト長</th><th>説明</th></tr></thead><tbody><tr><td>aaguid</td><td>16</td><td>認証器のタイプを示す 128bit(16byte)の識別子のこと</td></tr><tr><td>credentialIdLength</td><td>2</td><td>クレデンシャル ID のバイト長を示す 16bit(2byte)の符号なしビッグエンディアン整数</td></tr><tr><td>credentialId</td><td>L</td><td>クレデンシャルを一意に識別する ID</td></tr><tr><td>credentialPublicKey</td><td>variable</td><td>COSE_Key 形式でエンコードされたクレデンシャル公開鍵(認証器で生成された公開鍵)</td></tr></tbody></table><p>ここに COSE_Key 形式でエンコードされた以降の認証フローで使用するための公開鍵が含まれているので、検証終了時に Database で永続化しておきます。</p><h3 id=attstmt>attStmt</h3><p>下図の赤枠でかこっている箇所の話です。</p><p><img src=https://shukawam.github.io/blog/img/2021/0404/att-stmt.png alt=attStmt></p><p>何やら、FIDO2 認証ベンダーの秘密鍵によって生成された署名や証明書が含まれていそうです。きちんとプロパティを見ていくと、以下のようになっています。(今回は Basic の場合)</p><table><thead><tr><th>プロパティ名</th><th>説明</th></tr></thead><tbody><tr><td>alg</td><td>COSE Algorithm Identifier で指定する sig(署名)の暗号化アルゴリズム</td></tr><tr><td>sig</td><td>FIDO 認証ベンダー固有の秘密鍵によって生成された署名</td></tr><tr><td>x5c</td><td>attestnCert (とその証明書チェーン)が含まれていて、それぞれ X.509 形式でエンコードされている</td></tr></tbody></table><p>署名の検証手順については、<a href=https://www.w3.org/TR/webauthn/#sctn-attestation-formats>6.5.2. Attestation Statement Formats</a>に記されています。(OSS のライブラリの開発などやフルスクラッチで実装しようという方以外は知らなくても大丈夫な部分かと思われます)</p><h1 id=参考>参考</h1><ul><li><a href=https://www.w3.org/TR/webauthn/>W3C WebAuthn</a></li></ul><section class=footnotes role=doc-endnotes><hr><ol><li id=fn:1 role=doc-endnote><p>Concise Binary Object Representation (CBOR)の略で、バイナリの JSON のようなもの <a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></section></div><div class=post-footer></div></article></main></body></html>