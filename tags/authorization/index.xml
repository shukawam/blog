<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Authorization on Shukawam's Daily Blog</title><link>https://shukawam.github.io/blog/tags/authorization/</link><description>Recent content in Authorization on Shukawam's Daily Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 12 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://shukawam.github.io/blog/tags/authorization/index.xml" rel="self" type="application/rss+xml"/><item><title>Microservicesの認証・認可</title><link>https://shukawam.github.io/blog/blog/2021/0512-microservices-authnz/</link><pubDate>Wed, 12 May 2021 00:00:00 +0000</pubDate><guid>https://shukawam.github.io/blog/blog/2021/0512-microservices-authnz/</guid><description>始めに マイクロサービスの認証・認可に関して調べたことをまとめます。本記事はプログラミング言語によらない設計レベルの話が中心となっています。
認証・認可とは？ 認証(Authentication/AuthN) 誰であるかを確認すること リソースへのアクセス権限とは無関係 認可(Authorization/AuthZ) 何に対してアクセスできるかどうかを確認すること 誰であるかは無関係だが、通常は認証済みのアカウントに対してアクセス権限を与えるというフローが大半を占めている 認証・認可で一般的に求められる要件 一般的に以下が求められます。
ステートレスなプロトコル(HTTP)上でのユーザーの状態の管理 一貫したログイン、ログアウトの体験 ユーザーのリソースに対するアクセス権限管理 モノリス時代の認証・認可 モノリスの定義 あえて書くほどではないと思いますが、本記事でモノリスと言った場合には以下のような意味を持っています。
全てのコードが単一のプロセスにパッケージ化されデプロイされているシステム
モノリスでの認証・認可 こちらは典型的なモノリスなアプリケーションを示しています。
実装に左右されるところもあるかもしれませんが、認証・認可を実現する際、典型的には
フィルター相当(図中Auth)を実装し、本機能(図中Services)へアクセスする前にアイデンティティとアクセス権限の確認 ステートレスなプロトコル(HTTP)上でユーザーの状態を管理するため、サーバがクライアントに対して発行するセッションをどこかしらで管理することでユーザーの状態管理 ということを行います。この手の設計だと前述した認証・認可に求められる要件である
ステートレスなプロトコル(HTTP)上でのユーザーの状態の管理 一貫したログイン、ログアウトの体験 ユーザーのリソースに対するアクセス権限管理 は比較的容易に実現することができます。(いずれもサービスが分割されていないことに起因します)
前述したモノリスでの認証・認可を実現するための代表的な設計パターンを記します。後のマイクロサービスの認証・認可を考えるときにも使える考え方なのでより設計がシンプルなモノリスで原則を理解したほうが良いと思います。大きく 2 通りあります。
Distributed Session Management Token Based Auth それぞれについて見ていきます。
Distributed Session Management(Monolith) 実際に稼働しているシステムだと、
より多くのトラフィックを処理する 冗長化構成をとる etc. といった理由から Application の前段に Load Balancer を用いて負荷分散することが多いと思います。具体的には以下のような構成です。</description></item></channel></rss>