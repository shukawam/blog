+++
title = "Microservicesの認証"
author = "Shuhei, Kawamura"
date = "2021-05-12"
tags = ["microservices", "authentication", "authorization", "java", "microprofile"]
categories = ["tech"]
draft = "true"
+++

# 始めに

マイクロサービスの認証に関して調べたことをまとめます。本記事はプログラミング言語によらない設計レベルの話が中心となっています。

# 認証とは？

- 認証(Authentication/AuthN)
  - 誰であるかを確認すること
  - リソースへのアクセス権限とは無関係

# 認証で一般的に求められる要件

一般的に以下が求められます。

- ステートレスなプロトコル(HTTP)上でのユーザーの状態の管理
- 一貫したログイン、ログアウトの体験
- ユーザーのリソースに対するアクセス権限管理

# モノリス時代の認証

## モノリスの定義

あえて書くほどではないと思いますが、本記事でモノリスと言った場合には以下のような意味を持っています。  
**全てのコードが単一のプロセスにパッケージ化されデプロイされているシステム**

## モノリスでの認証

こちらは典型的なモノリスなアプリケーションを示しています。

![monolith](https://shukawam.github.io/blog/img/2021/0510/monolith.png)

実装に左右されるところもあるかもしれませんが、認証を実現する際、典型的には

- フィルター相当(図中`Auth`)を実装し、本機能(図中`Services`)へアクセスする前にアイデンティティとアクセス権限の確認
- ステートレスなプロトコル(HTTP)上でユーザーの状態を管理するため、サーバがクライアントに対して発行するセッションをどこかしらで管理することでユーザーの状態管理

ということを行います。この手の設計だと前述した認証に求められる要件である

> - ステートレスなプロトコル(HTTP)上でのユーザーの状態の管理
> - 一貫したログイン、ログアウトの体験
> - ユーザーのリソースに対するアクセス権限管理

は比較的容易に実現することができます。(いずれもサービスが分割されていないことに起因します)

前述したモノリスでの認証を実現するための代表的な設計パターンを記します。後のマイクロサービスの認証を考えるときにも使える考え方なのでより設計がシンプルなモノリスで原則を理解したほうが良いと思います。大きく 2 通りあります。

- Distributed Session Management
- Token Based Auth

それぞれについて見ていきます。

## Distributed Session Management(Monolith)

実際に稼働しているシステムだと、

- より多くのトラフィックを処理する
- 冗長化構成をとる
- etc.

といった理由から Application の前段に Load Balancer を用いて負荷分散することが多いと思います。具体的には以下のような構成です。

![monolith-lb](https://shukawam.github.io/blog/img/2021/0510/monolith-lb.png)

この時、何らかの方法で複数 Application でセッションが共有される仕組みを取り入れる必要があります。方法はいくつかあって

- スティッキーセッションを使う
  - 後続のすべてのリクエストをその最初のリクエストを処理したサーバに対して送られることを保証する仕組み
- セッションレプリケーションを行う
  - 各サーバがセッションデータを保存し、そのデータをネットワークを介して同期を取ること
- セッションを中央集権的に管理する
  - セッションを管理するためのサーバを追加し、そのサーバで中央集権的にセッションを管理する

といった手法が一般的です。

## Token Based Auth(Monolith)

ID/Password を入力することで、リソースにアクセスすることが可能なトークンを取得することができる。トークンを取得した以降の通信は、そのトークンを使用することでリソースへのアクセスを行う。全体像は以下のようになる。

![monolith-client-token](https://shukawam.github.io/blog/img/2021/0510/monolith-client-token.png)

※一般的な手法は後述します。

# マイクロサービス時代の認証

## マイクロサービスの定義

マイクロサービスの標準的な言葉の定義はないですが、[モノリスからマイクロサービスへ](https://www.oreilly.co.jp/books/9784873119311/)で記されている定義を借りると、

- ビジネスドメインに基づいてモデル化された、独立してデプロイ可能なサービス
- サービス同士は、ネットワークを介して相互に通信してシステムを形成する

といった特徴、設計原則を持ちます。

## マイクロサービスでの認証

再掲となるが、認証に求められる要件は以下の通りである。

> - ステートレスなプロトコル(HTTP)上でのユーザーの状態の管理
> - 一貫したログイン、ログアウトの体験
> - ユーザーのリソースに対するアクセス権限管理

モノリスなアプリケーションであればこれらの要件は比較的容易に満たすことができるという事を前述したが、マイクロサービスではサービスが分割されているという設計上簡単には実現できない。
この課題を解決する最もシンプルな方法がモノリスのアプリケーションの設計を真似る(各サービス毎に認証用の実装を持つ)という設計を行う事であるが、以下の理由から採用するべきではないと言われている。

- 機能追加等に伴い新しいサービスが追加されるたびに当該機能 + 認証の機能を実装する必要がある
- 仮に全サービスでデータベースをスキーマレベルで共有した場合、データベースが単一障害点となる

そのため、通常はマイクロサービスの設計原則に従い、認証の機能に焦点を当てたサービスを用意することが良いとされている。具体的には以下のような構造となる。

![typical-microservices](https://shukawam.github.io/blog/img/2021/0510/typical-microservices.png)

これにより、他のサービスは専門の機能に集中することができ、システム全体のスケーラビリティと疎結合性を向上させることができる。

さて、肝心の認証の設計であるがこれはマイクロサービスだからと言って特別なことはなく、モノリスでの認証でも取り上げた 2 つの方法(Distributed Session/Token Based Auth)に則って設計していくことになる。また、以下で取り上げる設計方針は**いずれも銀の弾丸ではないため、各々の要件に合わせて選択する必要がある**。判断の際に微力ながら役に立つようにそれぞれの課題感も合わせて書いておきます。

## Distributed Session Management(Microservices)

マイクロサービスで分散セッションを取り扱う際の典型的な構造は以下のよう。

![microservices-session](https://shukawam.github.io/blog/img/2021/0510/microservices-session.png)

大まかなフローは、このようになる。

1. ユーザーがサービスに対してアクセスする
2. Cookie に SessionID が保存されていない場合は、認証を取り扱うサービスである`Auth`へリダイレクトする
3. `Auth` サービスでユーザーのセッションを作成し、セッションストア(図中の Distribution Session Store)へ保存し、ユーザーに SessionId を返却する
4. 取得した SessionID を使用してサービスに対してアクセスを再要求する
   - 各サービスはセッションストアに SessionID を使用して問い合わせユーザーのステータスを取得し、適切な応答をする

課題としては以下のようなことが挙げられます。

- 毎リクエストでセッションストアへユーザーのステータスを問い合わせる必要があるため、性能劣化に繋がる
- セッションストアとの繋ぎこみの実装が必要
- 各サービスで SessionID が存在しない場合のリダイレクト処理などが必要となり実装が多少複雑になる

## Token Based Auth(Microservices)

次に、ID/Password 等を入力することで得られるトークンを使用するパターンについてです。モノリスの時には詳細に紹介しませんでしたが、細かく分類すると以下の 3 パターンの実装に落ち着きそうです。

- Single Sign On
- Client Side Token
- API Gateway + Client Side Token

### Single Sign On Server

Single Sign On(SSO)は、ユーザーが一つの認証情報で複数のアプリケーションに対してアクセスできるようにする認証プロセスの事です。マイクロサービスの場合は、マイクロサービスの場合はサービス全体を Resource Server(以降、RS)と SSO Server と見るとモノリスの場合の SSO に置き換えて考えやすいと思います。

![microservices-sso](https://shukawam.github.io/blog/img/2021/0510/microservices-sso.png)

ユーザが実際に RS からリソースを取得する際の一連の流れをシーケンスに起こすと以下のようになります。

![microservices-sso-sequence](https://shukawam.github.io/blog/img/2021/0510/microservices-sso-sequence.png)

1. ユーザーがリソースを取得するために RS に対してアクセスを要求する
2. RS は、ユーザーがトークンを持っているかチェックする
   - トークンを所持している場合
     1. SSO サーバから有効なトークンを取得する(図中 4 に相当)
     2. RS に対して取得したトークンを用いてリソースの取得要求を発行する(図中 5 に相当)
     3. トークンが有効であった場合は、リソースが返却される(図中 6, 7 に相当)
   - トークンを所持していない場合
     1. リクエストを SSO サーバに対してリダイレクトする(図中 2, 3 に相当)
     2. SSO サーバから有効なトークンを取得する(図中 4 に相当)
     3. RS に対して取得したトークンを用いてリソースの取得要求を発行する(図中 5 に相当)
     4. トークンが有効であった場合は、リソースが返却される(図中 6, 7 に相当)

導入時の課題としては以下のようなことが挙げられます。

- SSO Server が単一障害点となる
- リクエストの度に必ず SSO Server へトークンの妥当性を検証するためのリクエストを発行するため性能劣化に繋がる
- 特にサービスをまたいだ統一的なログアウトの設計が複雑になる

### Client Side Token

Client Side Token を用いた認証のポイントは SSO の課題であった**リクエストの度に必ず SSO サーバへトークンの妥当性を確認するためのリクエストを発行する**という事がなくなるため、全体のトラフィックを減らすことができるという点です。トークンの検証は RS 自体で完結させることで余計なトラフィックを減らしているというわけです。この手の話の時には、よく [JWT(JSON Web Token)](https://jwt.io/)が使用されます。こちらもユーザーが実際に RS からリソースを取得するときの一連の流れを見てみます。

![microservices-jwt-sequence](https://shukawam.github.io/blog/img/2021/0510/microservices-jwt-sequence.png)

1. ユーザーがリソースを取得するために RS に対してアクセスを要求する
2. RS は、ユーザーが JWT を所持しているかチェックする
   - 所持している場合
     1. RS で JWT の検証を行う(図中 7 に相当)
     2. 有効であれば、RS から該当のリソースが返却される(図中 8 に相当)
   - 所持していない場合
     1. 認証サーバに対して認証情報(ID/Password etc.)を送信する(図中 3 に相当)
     2. 送信されてきた認証情報の検証を実施し、ユーザーの権限や有効期限等を含む JWT を生成し、返却する(図中 4, 5 に相当)
     3. 返却された JWT を使用し、RS に対してリソースの要求を行う(図中 6 に相当)
     4. RS で JWT の検証を行う(図中 7 に相当)
     5. 有効であれば、RS から該当のリソースが返却される(図中 8 に相当)

こちらの方式も導入時に以下の課題が挙げられます。

- JWT 内に有効期限を示す claim(exp)が存在するが、その有効期限まで何もしなければ JWT が有効だという事
  - ログアウト時の方針を検討するのが難しい

JWT のライフサイクル問題(主に、ログアウト時)であるが、典型的な解決策としては以下のような事が考えられる。

- クライアントサイドで保存しているストア(Session Storage etc.)からログアウト時に JWT を破棄する
  - もっとも単純な方法だが、JWT の発行元(認証サーバ)がクライアントサイドで JWT を破棄したことを知りえないので安全性に懸念が残る
- トークンの有効期限を短めに設定する
  - UX 低下の原因となるが、上記の方法よりは安全性を確保できる

### API Gateway + Client Side Token

先ほどの JWT を使用した設計に、API Gateway パターンを追加します。バックエンドサービスに対するリバースプロキシの役割を持つ API Gateway にトークンの管理を集約させることですっきりさせる方針です。全体像は以下の通り。

![microservices-api-gateway](https://shukawam.github.io/blog/img/2021/0510/microservices-api-gateway.png)

この方式のポイントは、API Gateway で JWT を変換してクライアントに返却するところです。一見無意味な変換に思えるかもしれませんが、変換のために使用したデータを API Gateway で管理することに意味があります。API Gateway Pattern を用いない方式では、ユーザーの状態管理(主に、ログアウト関連)に課題がありましたが、こちらの方式では、変換のために使用したデータを破棄することで Opaque Token ↔ JWT への変換が不可能となり、ユーザーがリソースに対してアクセスするためには、JWT を再要求する必要があります。つまり、サービスをまたいだ統一的なユーザーのログアウト処理を比較的容易に実現することができます。ここまで、メリットばかり書いてきましたが、課題もいくつかあります。

- API Gateway が単一障害点となる可能性がある
- Opaque Token ↔ JWT の変換に使用するデータを管理するためのストレージを別途用意する必要があるのでその運用も考慮する必要がある

# 終わりに

マイクロサービスの認証に対する代表的な設計パターンについて調べたことをまとめてみました。繰り返しになりますが、**いずれのパターンも銀の弾丸ではないため各々の要件に合わせて方式をしっかりと選定する**必要があります。  
いつになるか分かりませんが、Java で Client Side Token を使った認証のパターンを実装する記事も書きたいと思います。

# 参考

- [Authentication and Authorization of End User in Microservice Architecture](https://iopscience.iop.org/article/10.1088/1742-6596/910/1/012060/pdf)
- [モノリスからマイクロサービスへ](https://www.oreilly.co.jp/books/9784873119311/)
- [jwt.io](https://jwt.io/)
